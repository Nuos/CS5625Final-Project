<!DOCTYPE html>
<!-- saved from url=(0071)http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System -->
<html lang="en-gb" dir="ltr" class="client-chrome client-chrome-2 client-webkit client-mac"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>OpenGL:Tutorials:Basic Bones System - GPWiki</title>
<meta name="generator" content="MediaWiki 1.17.0">
<link rel="shortcut icon" href="http://content.gpwiki.org/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://content.gpwiki.org/opensearch_desc.php" title="GPWiki (en-gb)">
<link rel="EditURI" type="application/rsd+xml" href="http://content.gpwiki.org/api.php?action=rsd">
<link rel="copyright" href="http://www.gnu.org/licenses/old-licenses/fdl-1.2.txt">
<link rel="alternate" type="application/atom+xml" title="GPWiki Atom feed" href="http://content.gpwiki.org/index.php?title=Special:RecentChanges&feed=atom">
<link rel="stylesheet" href="http://content.gpwiki.org/load.php?debug=false&lang=en-gb&modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&only=styles&skin=vector&*">
<meta name="ResourceLoaderDynamicStyles" content="">
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #b1b100;}
.c.source-c .kw2 {color: #000000; font-weight: bold;}
.c.source-c .kw3 {color: #000066;}
.c.source-c .kw4 {color: #993333;}
.c.source-c .co1 {color: #666666; font-style: italic;}
.c.source-c .co2 {color: #339933;}
.c.source-c .coMULTI {color: #808080; font-style: italic;}
.c.source-c .es0 {color: #000099; font-weight: bold;}
.c.source-c .es1 {color: #000099; font-weight: bold;}
.c.source-c .es2 {color: #660099; font-weight: bold;}
.c.source-c .es3 {color: #660099; font-weight: bold;}
.c.source-c .es4 {color: #660099; font-weight: bold;}
.c.source-c .es5 {color: #006699; font-weight: bold;}
.c.source-c .br0 {color: #009900;}
.c.source-c .sy0 {color: #339933;}
.c.source-c .st0 {color: #ff0000;}
.c.source-c .nu0 {color: #0000dd;}
.c.source-c .nu6 {color: #208080;}
.c.source-c .nu8 {color: #208080;}
.c.source-c .nu12 {color: #208080;}
.c.source-c .nu16 {color:#800080;}
.c.source-c .nu17 {color:#800080;}
.c.source-c .nu18 {color:#800080;}
.c.source-c .nu19 {color:#800080;}
.c.source-c .me1 {color: #202020;}
.c.source-c .me2 {color: #202020;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]-->
<script src="./OpenGL Tutorials Basic Bones System - GPWiki_files/cb=gapi.loaded_1" async=""></script><script src="./OpenGL Tutorials Basic Bones System - GPWiki_files/cb=gapi.loaded_0" async=""></script><script type="text/javascript" async="" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/plusone.js" gapi_processed="true"></script><script type="text/javascript" async="" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/ga.js"></script><script type="text/javascript">
 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-32686658-1']);
 _gaq.push(['_setDomainName', 'gpwiki.org']);
 _gaq.push(['_trackPageview']);
 (function() {
   var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
 })();
 </script><style type="text/css"></style>
<style>.gc-bubbleDefault{background-color:transparent !important;text-align:left;padding:0 !important;margin:0 !important;border:0 !important;table-layout:auto !important}.gc-reset{background-color:transparent !important;border:0 !important;padding:0 !important;margin:0 !important;text-align:left}.pls-bubbleTop{border-bottom:1px solid #ccc !important}.pls-topTail,.pls-vertShimLeft,.pls-contentLeft{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/border_3.gif) !important}.pls-topTail{background-repeat:repeat-x !important;background-position:bottom !important}.pls-vertShim{background-color:#fff !important;text-align:right}.pls-vertShimLeft{background-repeat:repeat-y !important;background-position:right !important;height:4px}.pls-vertShimRight{height:4px}.pls-confirm-container .pls-vertShim{background-color:#fff3c2 !important}.pls-contentWrap{background-color:#fff !important;position:relative !important;vertical-align:top}.pls-contentLeft{background-repeat:repeat-y;background-position:right;vertical-align:top}.pls-dropRight{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleDropR_3.png) !important;background-repeat:repeat-y !important;vertical-align:top}.pls-vert,.pls-tailleft,.pls-dropTR .pls-dropBR,.pls-dropBL,.pls-vert img{vertical-align:top}.pls-dropBottom{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleDropB_3.png) !important;background-repeat:repeat-x !important;width:100%;vertical-align:top}.pls-topLeft{background:inherit !important;text-align:right;vertical-align:bottom}.pls-topRight{background:inherit !important;text-align:left;vertical-align:bottom}.pls-bottomLeft{background:inherit !important;text-align:right}.pls-bottomRight{background:inherit !important;text-align:left;vertical-align:top}.pls-tailtop,.pls-tailright,.pls-tailbottom,.pls-tailleft{display:none;position:relative}.pls-tailbottom,.pls-tailtop,.pls-tailright,.pls-tailleft,.pls-dropTR,.pls-dropBR,.pls-dropBL{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleSprite_3.png) !important;background-repeat:no-repeat}.pls-tailbottom{background-position:-23px 0}.pls-confirm-container .pls-tailbottom{background-position:-23px -10px}.pls-tailtop{background-position:-19px -20px}.pls-tailright{background-position:0 0}.pls-tailleft{background-position:-10px 0}.pls-tailtop{vertical-align:top}.gc-bubbleDefault td{line-height:0;font-size:0}.pls-topLeft img,.pls-topRight img,.pls-tailbottom{vertical-align:bottom}.pls-bottomLeft img,.bubbleDropTR,.pls-dropBottomL img,.pls-dropBottom img,.pls-dropBottomR img,.pls-bottomLeft{vertical-align:top}.pls-dropTR{background-position:0 -22px}.pls-dropBR{background-position:0 -27px}.pls-dropBL{background-position:0 -16px}.pls-spacertop,.pls-spacerright,.pls-spacerbottom,.pls-spacerleft{position:static !important}.pls-spinner{bottom:0;position:absolute;left:0;margin:auto;right:0;top:0}</style></head>
<body class="mediawiki ltr ns-0 ns-subject page-OpenGL_Tutorials_Basic_Bones_System skin-vector">

<!-- Place this render call where appropriate -->
<script type="text/javascript">
  window.___gcfg = {lang: 'en-GB'};

  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>

		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">OpenGL:Tutorials:Basic Bones System <div style="height: 20px; width: 90px; display: inline-block; text-indent: 0px; margin: 0px; padding: 0px; background-color: transparent; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; background-position: initial initial; background-repeat: initial initial;" id="___plusone_0"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="position: static; top: 0px; width: 90px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 20px;" tabindex="0" vspace="0" width="100%" id="I0_1364763828317" name="I0_1364763828317" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/fastbutton.html" allowtransparency="true" data-gapiattached="true" title="+1"></iframe></div></h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
				<!-- tagline -->
				<div id="siteSub">From GPWiki</div>
				<!-- /tagline -->
				<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Jump to: <a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#mw-head">navigation</a>,
					<a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodytext -->
				<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2> <span class="toctoggle">[<a id="togglelink" class="internal" href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#">hide</a>]</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#What_is_a_bone_system"><span class="tocnumber">1</span> <span class="toctext">What is a bone system</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Why_use_bones"><span class="tocnumber">2</span> <span class="toctext">Why use bones</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Keyframe_animation"><span class="tocnumber">2.1</span> <span class="toctext">Keyframe animation</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Advantages"><span class="tocnumber">2.1.1</span> <span class="toctext">Advantages</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Disadvantages"><span class="tocnumber">2.1.2</span> <span class="toctext">Disadvantages</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-6"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Skeletal_animation"><span class="tocnumber">2.2</span> <span class="toctext">Skeletal animation</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#advantages_2"><span class="tocnumber">2.2.1</span> <span class="toctext">advantages</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Disadvantages_2"><span class="tocnumber">2.2.2</span> <span class="toctext">Disadvantages</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#So_should_I_always_use_bones.3F"><span class="tocnumber">2.2.3</span> <span class="toctext">So should I always use bones?</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#How_does_a_bone_system_work.3F"><span class="tocnumber">3</span> <span class="toctext">How does a bone system work?</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#The_skeletal_structure"><span class="tocnumber">4</span> <span class="toctext">The skeletal structure</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Using_bones"><span class="tocnumber">4.1</span> <span class="toctext">Using bones</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Should_I_use_a_bone_structure_or_a_joint_structure.3F"><span class="tocnumber">4.2</span> <span class="toctext">Should I use a bone structure or a joint structure?</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Animating.3F"><span class="tocnumber">5</span> <span class="toctext">Animating?</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Switching_between_movements"><span class="tocnumber">5.1</span> <span class="toctext">Switching between movements</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#A_simple_skeletal_system_in_2D"><span class="tocnumber">6</span> <span class="toctext">A simple skeletal system in 2D</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Simple_hierarchical_structure_of_bones"><span class="tocnumber">6.1</span> <span class="toctext">Simple hierarchical structure of bones</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Drawing_the_skeleton_in_2D"><span class="tocnumber">6.2</span> <span class="toctext">Drawing the skeleton in 2D</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Moving_the_structure"><span class="tocnumber">6.3</span> <span class="toctext">Moving the structure</span></a>
<ul>
<li class="toclevel-3 tocsection-20"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Moving_the_puppet_around"><span class="tocnumber">6.3.1</span> <span class="toctext">Moving the puppet around</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Selecting_a_bone"><span class="tocnumber">6.3.2</span> <span class="toctext">Selecting a bone</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Rotating_a_bone"><span class="tocnumber">6.3.3</span> <span class="toctext">Rotating a bone</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Changing_length_of_a_bone"><span class="tocnumber">6.3.4</span> <span class="toctext">Changing length of a bone</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Set_a_degree_of_freedom_for_our_bones"><span class="tocnumber">6.3.5</span> <span class="toctext">Set a degree of freedom for our bones</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-25"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Animating"><span class="tocnumber">6.4</span> <span class="toctext">Animating</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Keyframes"><span class="tocnumber">6.4.1</span> <span class="toctext">Keyframes</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Interpolation"><span class="tocnumber">6.4.2</span> <span class="toctext">Interpolation</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Coding"><span class="tocnumber">6.4.3</span> <span class="toctext">Coding</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-29"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Simple_polygon_skinning"><span class="tocnumber">6.5</span> <span class="toctext">Simple polygon skinning</span></a>
<ul>
<li class="toclevel-3 tocsection-30"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#How_does_a_skin_work.3F"><span class="tocnumber">6.5.1</span> <span class="toctext">How does a skin work?</span></a>
<ul>
<li class="toclevel-4 tocsection-31"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Skinning_with_multiple_polygons"><span class="tocnumber">6.5.1.1</span> <span class="toctext">Skinning with multiple polygons</span></a></li>
<li class="toclevel-4 tocsection-32"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Working_on_joints"><span class="tocnumber">6.5.1.2</span> <span class="toctext">Working on joints</span></a>
<ul>
<li class="toclevel-5 tocsection-33"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Parent-side_drawing"><span class="tocnumber">6.5.1.2.1</span> <span class="toctext">Parent-side drawing</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-34"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Skinning_an_entire_mesh"><span class="tocnumber">6.5.1.3</span> <span class="toctext">Skinning an entire mesh</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-35"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#A_3D_application_using_bones"><span class="tocnumber">7</span> <span class="toctext">A 3D application using bones</span></a>
<ul>
<li class="toclevel-2 tocsection-36"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#A_check_before_starting"><span class="tocnumber">7.1</span> <span class="toctext">A check before starting</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Data_structures"><span class="tocnumber">7.2</span> <span class="toctext">Data structures</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-38"><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#Source_codes"><span class="tocnumber">8</span> <span class="toctext">Source codes</span></a></li>
</ul>
</td></tr></tbody></table>
<p><br>
</p>
<h2> <span class="mw-headline" id="What_is_a_bone_system">What is a bone system</span></h2>
<p>A bone system - aka skeletal system - is a technique used to create skeletal animations. A skeletal animation consists of a skin mesh and an associated bone structure, so moving a bone will move the associated vertices of the mesh, exactly as happens in reality: we each have a skeletal structure with muscles and skin on it.
</p>
<h2> <span class="mw-headline" id="Why_use_bones">Why use bones</span></h2>
<p>Traditional mesh programming uses "3D sprite" animation (or keyframe animation): you have a 3D mesh for each frame: just rendering frame after frame, produces the motion.
</p>
<h3> <span class="mw-headline" id="Keyframe_animation">Keyframe animation</span></h3>
<h4> <span class="mw-headline" id="Advantages">Advantages</span></h4>
<dl><dt> Simple to implement
</dt><dd> given a 3D mesh with framed animation, you just have to load each frame in memory and use a pointer to navigate through the frame
</dd><dt> Fast
</dt><dd> once loaded in memory you simply render the mesh of the actual frame: no calculations are needed
</dd><dt> Looks good
</dt><dd> Since each model is pre-made, you are sure that the model will look like it did when you created it
</dd></dl>
<h4> <span class="mw-headline" id="Disadvantages">Disadvantages</span></h4>
<dl><dt> Memory
</dt><dd> Loading a mesh for each frame of the animation uses a lot of memory, especially if there are many different characters in our game, and if there are lots of animations (walking, running, sitting, using, shooting, ...)
</dd><dt> No/few interaction
</dt><dd> Interaction with the world is "fake": you must have an animation for each possible interaction and of course you can't apply (or it's complex and slow to implement) physics to your meshes.
</dd></dl>
<p>Of course if you need an animation for a little bunny in your game - as a non-principal character - which is composed of 3-4 frames, 100 vertices per frame, with one single action (running), using the 3D meshes is a good idea: memory waste isn't high, and since we'll have many bunnies, we prefer to not waste computation time.
</p><p>But what if you have to write a fighting game (like Soul Calibur, Tekken or Street Fighter)? Yes, the old Street Fighter used 2D sprites to fight, but now, we have a great technique at our disposal: skeletal animation, using bones.
</p>
<h3> <span class="mw-headline" id="Skeletal_animation">Skeletal animation</span></h3>
<h4> <span class="mw-headline" id="advantages_2">advantages</span></h4>
<dl><dt> Memory
</dt><dd> This uses very little memory: each character has a single model. Each animation and each action, is a set of moves done by the bones (few vertices) and not by the entire mesh (many vertices).
</dd><dt> High interaction
</dt><dd> Once you can master and move each part of the mesh as you like, you can make it interact with the world: kicking a wall, the leg will stop when it touches the wall, since this animation is computed in real-time by the bone system. Of course many other actions are possible: moving the head, dancing, fighting etc.
</dd><dt> Upgradability and reuse
</dt><dd> Imagine you have created a fighting game, each fighter can walk, run and kick. Using skeletons you can export a single mesh for each fighter and a file with movements for each action: walk, run and kick. If you need to add a punch action, you don't have to touch player's meshes: you just have to export another movement file, and all the fighters can use that, without modifying meshes or the game engine.
</dd></dl>
<h4> <span class="mw-headline" id="Disadvantages_2">Disadvantages</span></h4>
<dl><dt> Computation time
</dt><dd> Of course, moving a bone and related vertices takes some time that is added to the rendering time. For this reason, bones are a modern technique, not used in the past (in fact I don't think the Street Fighter game used a bone system).
</dd><dt> Joints are visible
</dt><dd> A disadvantage in this system is that joints are visible, since the animation is computed in realtime, and of course sometimes we don't have enough processing power to compute complex calculations on the joint.
</dd></dl>
<h4> <span class="mw-headline" id="So_should_I_always_use_bones.3F">So should I always use bones?</span></h4>
<p>Absolutely not. Sometimes it's far more efficient to use a classic 3D framed model, especially for animations that involve few interactions with the world, or for a great number of mesh instances.
Bone systems are great when you need interaction between characters, like FPS or fighting games, or when you want bodies (alive or not) to follow the laws of physics.
You can also use this method if you need a lot of control over the animation frames: for example, if you need to implement a "bullet time" effect in your game (like in the movie "The Matrix") you need to slow down your animation, and bones allow you to run your animation smoothly at an arbitrary speed.
</p>
<h2> <span class="mw-headline" id="How_does_a_bone_system_work.3F">How does a bone system work?</span></h2>
<p>This kind of system involves some elements:
</p>
<ol><li> The object mesh (usually you can use a single mesh, but also more than one)
<ul><li> Using weighted vertexes
</li></ul>
</li><li> A skeleton for the mesh, composed by a hierarchy of
<ul><li> Bones
</li><li> Joints
</li></ul>
</li></ol>
<p>The mesh is connected with the skeleton. Each vertex of the mesh is associated to a bone (or more than one) and has a weight, which means how much bone movement affects the vertex movement. Each bone in the skeleton is connected to two joints, and each joint is connected to at least one bone.
When you have to do an animation, just pre-calculate the key-positions of your skeleton (maybe with a 3D editing program, like Blender or MaYa), then create an algorithm that calculate interpolation between movements. Finally, just apply the interpolation of the vertices basing your calculations on the vertex weights and bone hierarchy.
</p>
<center><a href="http://content.gpwiki.org/index.php/File:Model_example.png" class="image" title="Example of skinned mesh"><img alt="Example of skinned mesh" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/Model_example.png" width="300" height="351"></a></center>
<p>The act of connecting a mesh to a bone structure is called "skinning". When you apply a skin you should also define vertex weights for each bone. Usually this is done in the 3D modeling software (I love Blender, and it allows you to do this), then you can export the mesh with weighted vertices, bones and textures (if you need to).
Sometimes, programs allow you to import a pre-made skeletal structure, then you can build your mesh around it. This is common with highly-customizable games. For example, if you want to build your own character in UT/Quake, just open the default skeletal structure with a modeling program (like MilkShape 3D, which comes with importer/exporter and pre-made skeletal structures), build your model around it, and export the mesh for the game you want to mod.
As you can see, it's easy to make new characters with a bone system: just create a mesh and associate the vertices.
</p>
<h2> <span class="mw-headline" id="The_skeletal_structure">The skeletal structure</span></h2>
<p>Mainly the skeletal structure is organized in a hierarchical way: for example femur is the father of tibia and pelvis is father of femur, but basically you can view the skeletal structure as tree.
</p><p>You can define this tree by using only bones or only joints (maybe also using both, though I see no advantage to doing so)
</p>
<h3> <span class="mw-headline" id="Using_bones">Using bones</span></h3>
<p>You can define a structure similar to this
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">struct</span> Bone_t
 <span class="br0">{</span>
    <span class="kw4">float</span> x1<span class="sy0">,</span> y1<span class="sy0">,</span> x2<span class="sy0">,</span> y2<span class="sy0">;</span>
    <span class="kw4">struct</span> Bone_t <span class="sy0">*</span>father<span class="sy0">;</span>
 <span class="br0">}</span><span class="sy0">;</span></pre></div></div>
<p>Here a bone is defined like a line, with a father as a pointer of the same type.
When a child bone is linked to another, just use the father's (x2, y2) as the starting point of this bone. There are 2 ways to do this
</p><p><b>Children coords are offset with respect to the father</b>
In this case child.x1 and child.y1 should be both at 0.0. So we can just set an offset like this
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> child.<span class="me1">x1</span> <span class="sy0">=</span> child.<span class="me1">y1</span> <span class="sy0">=</span> <span class="nu16">0.0</span><span class="sy0">;</span>
 child.<span class="me1">x2</span> <span class="sy0">=</span> <span class="nu16">10.0</span><span class="sy0">;</span>
 child.<span class="me1">y2</span> <span class="sy0">=</span> <span class="nu16">15.0</span><span class="sy0">;</span>
 child.<span class="me1">parent</span> <span class="sy0">=</span> <span class="sy0">&amp;</span>parent<span class="sy0">;</span>
&nbsp;
 <span class="coMULTI">/* Now drawing the bones */</span>
 child.<span class="me1">x1</span> <span class="sy0">=</span> child.<span class="me1">parent</span><span class="sy0">-&gt;</span>x2<span class="sy0">;</span>
 child.<span class="me1">y1</span> <span class="sy0">=</span> child.<span class="me1">parent</span><span class="sy0">-&gt;</span>y2<span class="sy0">;</span>
 child.<span class="me1">x2</span> <span class="sy0">+=</span> child.<span class="me1">x1</span><span class="sy0">;</span>
 child.<span class="me1">y2</span> <span class="sy0">+=</span> child.<span class="me1">y2</span><span class="sy0">;</span>
 draw<span class="br0">(</span>parent<span class="br0">)</span><span class="sy0">;</span>
 draw<span class="br0">(</span>child<span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p><b>Children coords are absolute</b>
In this case, child is positioned somewhere on the screen, so a child = {10.0, 11.0, 20.0, 21.0} is a line which goes from (10.0, 11.0) to (20.0, 21.0). Of course this method is Ok if you plan to explode your character in little pieces (so you can easily manage each bone as a different piece), but what if you have to compose bones of a normal skeleton, that is a child bone attached to a parent one? 
We can make a distinction: bone can be in an absolute position or at a relative position. 
Just add a flag to our structure that handle this, so
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">struct</span> Bone_t childTemp<span class="sy0">;</span>
&nbsp;
 child.<span class="me1">x1</span> <span class="sy0">=</span> <span class="nu16">10.0</span><span class="sy0">;</span>
 child.<span class="me1">y1</span> <span class="sy0">=</span> <span class="nu16">11.0</span><span class="sy0">;</span>
 child.<span class="me1">x2</span> <span class="sy0">=</span> <span class="nu16">20.0</span><span class="sy0">;</span>
 child.<span class="me1">y2</span> <span class="sy0">=</span> <span class="nu16">21.0</span><span class="sy0">;</span>
 child.<span class="me1">parent</span> <span class="sy0">=</span> <span class="sy0">&amp;</span>parent<span class="sy0">;</span>
&nbsp;
 <span class="coMULTI">/* Now drawing the bones */</span>
 <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>child.<span class="me1">isAbsolutedPositioned</span><span class="br0">)</span> <span class="coMULTI">/* This is relative to the parent's position, so translate it */</span>
 <span class="br0">{</span>
     childTemp.<span class="me1">x2</span> <span class="sy0">-=</span> child.<span class="me1">x1</span> <span class="sy0">-</span> child.<span class="me1">parent</span><span class="sy0">-&gt;</span>x2<span class="sy0">;</span>
     childTemp.<span class="me1">y2</span> <span class="sy0">-=</span> child.<span class="me1">y1</span> <span class="sy0">-</span> child.<span class="me1">parent</span><span class="sy0">-&gt;</span>y2<span class="sy0">;</span>
     childTemp.<span class="me1">x1</span> <span class="sy0">=</span> child.<span class="me1">parent</span><span class="sy0">-&gt;</span>x2<span class="sy0">;</span>
     childTemp.<span class="me1">y1</span> <span class="sy0">=</span> child.<span class="me1">parent</span><span class="sy0">-&gt;</span>y2<span class="sy0">;</span>
 <span class="br0">}</span>
 <span class="kw1">else</span>
 <span class="br0">{</span>
     <span class="coMULTI">/* This is already how we want it to be drawn, so do nothing */</span>
 <span class="br0">}</span>
 draw<span class="br0">(</span>parent<span class="br0">)</span><span class="sy0">;</span>
 draw<span class="br0">(</span>childTemp<span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Of course this calculation must be defined in draw(), but I'm placing it here for clarity.
</p><p>Anyway, this is only a method to define a bone. Some programmers prefer to use a single coord (x,y) for it's positioning and then an angle and a length relative to the parent - and some use an additional (x2, y2) coord to store the end of the bone, to avoid computing sin() and cos() functions every time a bone is drawn.
</p><p>Other programmers, don't even use bones. In fact, you can also define joints, and consider a bone as the space between then, but actually without using a bone structure, which is implicit: a bone is between 2 joints, so, defining a bone is like defining 2 joints, a father and a child.
The structure for a joint is like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">struct</span> Joint_t
 <span class="br0">{</span>
     <span class="kw4">float</span> x<span class="sy0">,</span> y<span class="sy0">;</span>
     <span class="kw4">struct</span> Joint_t <span class="sy0">*</span>parent<span class="sy0">;</span>
 <span class="br0">}</span><span class="sy0">;</span></pre></div></div>
<p>Of course, you can implement these structure (both Bone_t and Joint_t) using a pointer to the parent object (as I did) or using a structure for keeping all children, like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">struct</span> Bone_t
 <span class="br0">{</span>
     <span class="coMULTI">/* coords */</span>
     <span class="kw4">struct</span> Joint_t <span class="sy0">*</span>children<span class="br0">[</span>MAX_CHILDRENS<span class="br0">]</span><span class="sy0">;</span><span class="coMULTI">/* An array to pointers. You can use a null terminating */</span>
                                              <span class="coMULTI">/* pointer or just add a count variable */</span>
 <span class="br0">}</span><span class="sy0">;</span></pre></div></div>
<p>And as you might have thought, this way helps a lot for navigating the bone tree (starting from a root to the leaves), depending on your needs, you may also want to define both: pointers to children and a pointer to parent bone/joint.
</p>
<h3> <span class="mw-headline" id="Should_I_use_a_bone_structure_or_a_joint_structure.3F">Should I use a bone structure or a joint structure?</span></h3>
<p>It's your choice, but keep in mind that
</p>
<ul><li>Using bones means you can manage each one as you wish: if you plan to explode your model in little, articulated pieces, it's a good idea to use bones
</li><li>Using joints means you have less redundancy of positions: 3 joints are 2 bones, so you have to store only 3 points in memory, since 2 bones have one joint in common. When using a bone structure, you have 4 points in memory for 2 bones. Hence using joints saves memory, but it's ok only for connected bones.
</li><li>If you want to create a bone structure for a sea star (or a structure where there are bones of the same level), it's easy to do with only joints: one father joint is the center of the star. If you are using a bone structure you should create a "null bone", of length and angle 0, which works as a joint.
</li></ul>
<h2> <span class="mw-headline" id="Animating.3F">Animating?</span></h2>
<p>At this point now you should have a base about what a bone system is and what are it's capabilities. Before proceeding in creating a working system, there is another point to discuss: animation, of course. 
</p><p>Animating this kind of system can be done with 2 different techniques, but we'll talk about them later. Now it's important to understand the concept in common in both techniques: an animation is made of <b>keyframes</b> and <b>interpolation</b>.
As we said before using bones helps us to have control over each movement: since moving a bone corresponds to moving an entire set of weighted vertexes, and since we can handle each single bone, it's logical that we can produce frames with an arbitrary sample (that is: calculating 100 frames at 100fps looks like calculating 50 frames at 50fps, but with doubled sampling rate) - this is not possible (or it's difficult) with 3D sprites.
</p><p>Usually you'll want to use a precalculated animation: you have a file containing a finite set of frames representing the - for example - walking cycle.
Each of these frames is called a <i>keyframe</i> and represents a key position for each bone at a specific time.
Since we have keyframes, and we need a virtually infinite set of frames, we need to use interpolation.
Interpolation is (from wikipedia) "a method of constructing new data points from a discrete set of known data points". Our set is the keyframes taken from the file.
Actually this means that if you have a point at location (x1, y1) at time 0, and it is at (x2, y2) at time 10, interpolation can calculate (with a good approximation) all the positions of the points when time is between 0 and 10.
</p><p>In our case we'll use the <a href="http://content.gpwiki.org/index.php/Linear_Interpolation" title="Linear Interpolation">linear interpolation</a> for calculating the position of the bones in frames that aren't keyframes.
</p><p>Now that you know basically how an animation is done, let me explain the two techniques used in creating an animation.
</p>
<ol><li>Forward kinematic
</li><li>Inverse kinematic
</li></ol>
<p>Imagine you have an articulated puppet just like a drawing puppet or a GI Joe. Now let's try make to it walk (actually we don't want to move it in realtime, just calculate each frame of the animation).
If you use a forward kinematic, starting from a stand position, you have to rotate it's femur and it's tibia a little, then in the next frame you rotate them more, then it must extend it's leg to make a step, then it falls on a foot and the step is done. Doing this for both legs creates the walking cycle
</p><p>Then you can make it walk using the inverse kinematic. Just take its foot in your hands, and move the foot just like they would move in a walking cycle. The legs will follow the feet, and the animation cycle is done.
</p><p>(an image which explains the two concepts)
</p><p>Actually, FK is the one applied in a real body: each muscle rotates a bone of some degree respecting the parent bone - which muscles are fixed to.
But as you can see, IK is much more easy to use, since you just have to say: "I want this foot here", and the leg will move properly.
</p><p>As you can imagine, IK needs something to work as it should: a degree of movement and min/max degrees for each articulation.
For example, a knee can't be opened more than 180°, and can't be closed less then 20° or 30° (these are max/min degrees for the knee), and you also know that a knee has only one degree of movement: you can only open and close it.
Some other articulations, have more degrees of movement, for example a shoulder has 3 degrees of movement, since you can rotate an arm around the X Y or Z axes (you can throw your arms up or down, you can open or close your arms as when you embrace something, and you can rotate an arm on it's axis).
</p><p>FK doesn't need to know the degrees of movement for each articulation, since you move each bone as you wish.
</p><p>In both cases, we have to store some positions in each frame, and interpolate them to create an animation.
</p>
<h3> <span class="mw-headline" id="Switching_between_movements">Switching between movements</span></h3>
<p>As I said bones have several advantages over static meshes. One of these advantages is not really particular, but it's - graphically speaking - important. For example: your player is running, then, in the middle of the running cycle, you stop pressing the "run" button, and your player starts to walk, immediately.
In reality, this never happens: when you pass from a running state to a walking state, you have to slow down to decrease your speed, and then you start to walk, naturally interpolating your actions.
This seems normal to us, but it's actually hard to do in video games. 
In 2D and 3D games, when you use sprites instead of a bone system, this interpolation is quite difficult to realize, and usually this involves a lot of work from the graphic designers, since they have to draw all the interpolating movement between actions, and this takes lots of time and memory.
If instead of sprites you use a bone system, this issue is far more simple to solve, without needing lots of work with graphics.
Since you can handle each bone and interpolate the bone positions between key frames, why not interpolate between different actions, instead of just different frames? Infact, this is the solution to our problem: just interpolate different animations.
In this way you can easily switch between running and walking, without producing "time-zero" movements.
</p><p>Of course if you want to get better results, defining an additional animation cycle can help the movement: if you want to jump while running, the jumping animation while running is quite different than a jump while walking, and it's different than a jump when you aren't moving.
</p><p>A very good example of this "action interpolation" can be seen in the newest fighting games, like Soul Calibur 2, Tekken or Dead Or Alive 3.
Another very good example that comes in my mind - is in the Metroid Prime series, from Nintendo: Samus can morph herself in a sphere, and you can do this while running or walking, and IMHO the animation interpolation is done perfectly.
Also soccer games like PES or FIFA must have good interpolation between actions.
For a comparison, just look at these examples and then take a look at a fight in an old game like Street Fighter 2, where the "trick" to avoid a "time-zero" movement, was to execute actions sequentially, to avoid the necessity of interpolating animations (so for example, sequences like "run-jump-run" becomes like "run-stop-jump forward-stop-run").
</p>
<h1> <span class="mw-headline" id="A_simple_skeletal_system_in_2D">A simple skeletal system in 2D</span></h1>
<p>Now you should have a good background about skeletal animation. Now let's design a basic work, in two dimensions (for simplicity), to understand how bones work and to try our hand at this kind of programming.
</p><p>The system that follows is simple, actually used to learn how to program and manage bones. We'll follow a time line, starting from a simple example to go toward something "more difficult"
</p>
<ol><li>Simple hierarchical structure of bones
<ul><li>Here we define the structures, how the tree is composed, we define the functions and the structure to manage our skeleton
</li></ul>
</li><li>Drawing the skeleton in 2D
<ul><li>Then we define functions to draw the bones on the screen, using OpenGL in ortho view.
</li></ul>
</li><li>Moving the structure
<ul><li>Next we give users control over the bones: select a bone and move it
</li></ul>
</li><li>Animating
<ul><li>Then we start an animation: given an animation cycle, we play it.
</li></ul>
</li><li>Simple polygon skinning
<ul><li>When we have a simple bone system, we want to put some skin on it. We start by attaching some separate polygons.
</li></ul>
</li><li>Skinning a single mesh
<ul><li>Finally we attach one single mesh on the bones, and we can apply to them any single mesh.
</li></ul>
</li></ol>
<h2> <span class="mw-headline" id="Simple_hierarchical_structure_of_bones">Simple hierarchical structure of bones</span></h2>
<p>First of all let's create the Bone structure (yes, I prefer to use Bones instead of Joints, only because it sounds easy&nbsp;:D). And in this example, I prefer to use a bone calculated by angle and length, instead of 2 points in the space.
This structure must contain:
</p>
<ul><li>Coordinates of the starting point
</li><li>An angle
</li><li>A length
</li><li>Flags to determinate if the bone is in absolute position or not
</li><li>Hierarchy data (children and parent)
</li><li>A name, just for the sake of the example (of course you don't need this in a game)
</li></ul>
<p>So, let's define the structure:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="coMULTI">/* C code, made for tabs of 8 spaces
  * uint8_t is defined in the standard C header stdint.h
  */</span>
&nbsp;
 <span class="coMULTI">/* Define numbers and flags */</span>
 <span class="co2">#define MAX_CHCOUNT			8	/* Max children count */</span>
 <span class="co2">#define BONE_ABSOLUTE_ANGLE		0x01	/* Bone angle is absolute or relative to parent */</span>
 <span class="co2">#define BONE_ABSOLUTE_POSITION		0x02	/* Bone position is absolute in the world or relative to the parent */</span>
 <span class="co2">#define BONE_ABSOLUTE			(BONE_ABSOLUTE_ANGLE | BONE_ABSOLUTE_POSITION)</span>
&nbsp;
 <span class="kw4">typedef</span> <span class="kw4">struct</span> _Bone
 <span class="br0">{</span>
 	<span class="kw4">char</span> name<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="sy0">;</span>				<span class="coMULTI">/* Just for the sake of the example */</span>
 	<span class="kw4">float</span> x<span class="sy0">,</span>				<span class="coMULTI">/* Starting point x */</span>
 	      y<span class="sy0">,</span>				<span class="coMULTI">/* Starting point y */</span>
 	      a<span class="sy0">,</span>				<span class="coMULTI">/* Angle, in radians */</span>
 	      l<span class="sy0">;</span>				<span class="coMULTI">/* Length of the bone */</span>
&nbsp;
 	<span class="kw4">uint8_t</span> flags<span class="sy0">;</span>				<span class="coMULTI">/* Bone flags, 8 bits should be sufficient for now */</span>
 	<span class="kw4">uint8_t</span> childCount<span class="sy0">;</span>			<span class="coMULTI">/* Number of children */</span>
&nbsp;
 	<span class="kw4">struct</span> _Bone <span class="sy0">*</span>child<span class="br0">[</span>MAX_CHCOUNT<span class="br0">]</span><span class="sy0">,</span>	<span class="coMULTI">/* Pointers to children */</span>
 		     <span class="sy0">*</span>parent<span class="sy0">;</span>			<span class="coMULTI">/* Parent bone */</span>
 <span class="br0">}</span> Bone<span class="sy0">;</span></pre></div></div>
<p>After this of course we need to define some functions to handle bones. Actually I want to define these functions
</p>
<dl><dt>boneAddChild&nbsp;</dt><dd> Takes a bone and adds a child. If bone doesn't exists, this should create it (without a child)
</dd><dt>boneDumpTree&nbsp;</dt><dd> Takes a bone and print on stdout the hierarchy
</dd><dt>boneLoadStructure&nbsp;</dt><dd> Takes a file path and loads the bone tree from it
</dd><dt>boneFreeTree&nbsp;</dt><dd> Takes a bone and clears the memory
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="coMULTI">/* Create a bone and return it's address */</span>
 Bone <span class="sy0">*</span>boneAddChild<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="sy0">,</span> <span class="kw4">float</span> x<span class="sy0">,</span> <span class="kw4">float</span> y<span class="sy0">,</span> <span class="kw4">float</span> a<span class="sy0">,</span> <span class="kw4">float</span> l<span class="sy0">,</span> Uint8 flags<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="br0">)</span>
 <span class="br0">{</span>
 	Bone <span class="sy0">*</span>t<span class="sy0">;</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root<span class="br0">)</span> <span class="coMULTI">/* If there is no root, create one */</span>
 	<span class="br0">{</span>
 		<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="br0">(</span>root <span class="sy0">=</span> <span class="br0">(</span>Bone <span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span>Bone<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 			<span class="kw1">return</span> NULL<span class="sy0">;</span>
 		root<span class="sy0">-&gt;</span>parent <span class="sy0">=</span> NULL<span class="sy0">;</span>
 	<span class="br0">}</span>
 	<span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>root<span class="sy0">-&gt;</span>childCount <span class="sy0">&lt;</span> MAX_CHCOUNT<span class="br0">)</span> <span class="coMULTI">/* If there is space for another child */</span>
 	<span class="br0">{</span>
 		<span class="coMULTI">/* Allocate the child */</span>
 		<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="br0">(</span>t <span class="sy0">=</span> <span class="br0">(</span>Bone <span class="sy0">*</span><span class="br0">)</span><span class="kw3">malloc</span><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span>Bone<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 			<span class="kw1">return</span> NULL<span class="sy0">;</span> <span class="coMULTI">/* Error! */</span>
&nbsp;
 		t<span class="sy0">-&gt;</span>parent <span class="sy0">=</span> root<span class="sy0">;</span> <span class="coMULTI">/* Set it's parent */</span>
 		root<span class="sy0">-&gt;</span>child<span class="br0">[</span>root<span class="sy0">-&gt;</span>childCount<span class="sy0">++</span><span class="br0">]</span> <span class="sy0">=</span> t<span class="sy0">;</span> <span class="coMULTI">/* Increment the childCounter and set the pointer */</span>
 		root <span class="sy0">=</span> t<span class="sy0">;</span> <span class="coMULTI">/* Change the root */</span>
 	<span class="br0">}</span>
 	<span class="kw1">else</span> <span class="coMULTI">/* Can't add a child */</span>
 		<span class="kw1">return</span> NULL<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Set data */</span>
 	root<span class="sy0">-&gt;</span>x <span class="sy0">=</span> x<span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>y <span class="sy0">=</span> y<span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>a <span class="sy0">=</span> a<span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>l <span class="sy0">=</span> l<span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>flags <span class="sy0">=</span> flags<span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>childCount <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span>name<span class="br0">)</span>
 		<span class="kw3">strcpy</span><span class="br0">(</span>root<span class="sy0">-&gt;</span>name<span class="sy0">,</span> name<span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw1">else</span>
 		<span class="kw3">strcpy</span><span class="br0">(</span>root<span class="sy0">-&gt;</span>name<span class="sy0">,</span> <span class="st0">"Bone"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> MAX_CHCOUNT<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> NULL<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">return</span> root<span class="sy0">;</span>
 <span class="br0">}</span>
&nbsp;
 <span class="coMULTI">/* Free the bones */</span>
 Bone <span class="sy0">*</span>boneFreeTree<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root<span class="br0">)</span>
 		<span class="kw1">return</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Recursively call this function to free subtrees */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		boneFreeTree<span class="br0">(</span>root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw3">free</span><span class="br0">(</span>root<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">return</span> NULL<span class="sy0">;</span>
 <span class="br0">}</span>
&nbsp;
 <span class="coMULTI">/* Dump on stdout the bone structure. Root of the tree should have level 1 */</span>
 <span class="kw4">void</span> boneDumpTree<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="sy0">,</span> Uint8 level<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root<span class="br0">)</span>
 		<span class="kw1">return</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> level<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"#"</span><span class="br0">)</span><span class="sy0">;</span> <span class="coMULTI">/* We print # to signal the level of this bone. */</span>
&nbsp;
 	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"&nbsp;%4.4f&nbsp;%4.4f&nbsp;%4.4f&nbsp;%4.4f&nbsp;%d&nbsp;%d&nbsp;%s<span class="es1">\n</span>"</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>x<span class="sy0">,</span> root<span class="sy0">-&gt;</span>y<span class="sy0">,</span>
               root<span class="sy0">-&gt;</span>a<span class="sy0">,</span> root<span class="sy0">-&gt;</span>l<span class="sy0">,</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">,</span> root<span class="sy0">-&gt;</span>flags<span class="sy0">,</span> root<span class="sy0">-&gt;</span>name<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Recursively call this on my children */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		boneDumpTree<span class="br0">(</span>root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> level <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Now that we have these 3 simple functions to handle bones, let's try them!
I create this main function
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">int</span> argc<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">**</span>argv<span class="br0">)</span>
 <span class="br0">{</span>
 	Bone <span class="sy0">*</span>root<span class="sy0">,</span>
 	     <span class="sy0">*</span>tmp<span class="sy0">,</span>
 	     <span class="sy0">*</span>tmp2<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Create a root bone
 	 * this is a "null" bone which represent a single point, which is the center of the structure.
 	 * Do you remember the sea star example above?
 	 */</span>
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="br0">(</span>root <span class="sy0">=</span> boneAddChild<span class="br0">(</span>NULL<span class="sy0">,</span> <span class="nu0">100</span><span class="sy0">,</span> <span class="nu0">100</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"NullBone"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"Error! Can't create a root!<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw3">exit</span><span class="br0">(</span>EXIT_FAILURE<span class="br0">)</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* Creating a bone which has (x,y) == (0,0) and BONE_ABSOLUTE_POSITION NOT set
 	 *  causes this bone to start where its parent ends.
 	 * If ABSOLUTE_POSITION is off, x and y work as offsets with respect to the parents end position.
 	 * If it's on, then (x,y) will be placed at an absolute position on the screen.
 	 */</span>
 	boneAddChild<span class="br0">(</span>root<span class="sy0">,</span> <span class="nu0">100</span><span class="sy0">,</span> <span class="nu0">100</span><span class="sy0">,</span> M_PI_2<span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> BONE_ABSOLUTE<span class="sy0">,</span> <span class="st0">"Head"</span><span class="br0">)</span><span class="sy0">;</span>
 	tmp <span class="sy0">=</span> boneAddChild<span class="br0">(</span>root<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="sy0">-</span>M_PI_2<span class="sy0">,</span> <span class="nu0">30</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"Back"</span><span class="br0">)</span><span class="sy0">;</span>
  	tmp2 <span class="sy0">=</span> boneAddChild<span class="br0">(</span>tmp<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="sy0">-</span>M_PI_4<span class="sy0">,</span> <span class="nu0">30</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"LLeg"</span><span class="br0">)</span><span class="sy0">;</span>
 	boneAddChild<span class="br0">(</span>tmp2<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">30</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"LLeg2"</span><span class="br0">)</span><span class="sy0">;</span>
 	tmp2 <span class="sy0">=</span> 	boneAddChild<span class="br0">(</span>tmp<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">2</span> <span class="sy0">*</span> M_PI_4<span class="sy0">,</span> <span class="nu0">30</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"RLeg"</span><span class="br0">)</span><span class="sy0">;</span>
  	boneAddChild<span class="br0">(</span>tmp2<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">30</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"RLeg2"</span><span class="br0">)</span><span class="sy0">;</span>
 	tmp <span class="sy0">=</span> boneAddChild<span class="br0">(</span>root<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"LArm"</span><span class="br0">)</span><span class="sy0">;</span>
 	boneAddChild<span class="br0">(</span>tmp<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"LArm2"</span><span class="br0">)</span><span class="sy0">;</span>
 	tmp <span class="sy0">=</span> boneAddChild<span class="br0">(</span>root<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> M_PI<span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"RArm"</span><span class="br0">)</span><span class="sy0">;</span>
 	boneAddChild<span class="br0">(</span>tmp<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> M_PI<span class="sy0">,</span> <span class="nu0">20</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="st0">"RArm2"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	boneDumpTree<span class="br0">(</span>root<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	root <span class="sy0">=</span> boneFreeTree<span class="br0">(</span>root<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">return</span> EXIT_SUCCESS<span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Then, to facilitate the creating of bone structures, I created (and it took about 3 hours! [Difficult]) this function which loads a skeletal structure from a file. The file is in the same format outputted by the dump function above, which is:
</p>
<ol><li>Level made of #s, starting from 1 which is the root
</li><li>(x, y) coords, angle and length
</li><li>Flags
</li><li>Name
</li></ol>
<p>Here some examples of these files
</p><p><i>A star</i>
</p>
<pre>#   0   0     0    0   5   3  Root
##  0   0 0.000  100   0   0  One
##  0   0 1.256  100   0   0  Two
##  0   0 2.512  100   0   0  Three
##  0   0 3.768  100   0   0  Four
##  0   0 5.024  100   0   0  Five
</pre>
<p><i>A snake?</i>
</p>
<pre># 0.0000 0.0000 1.0000 50.0000 1 3 Root
## 0.0000 0.0000 1.0000 50.0000 1 0 One
### 0.0000 0.0000 1.0000 50.0000 1 0 Two
#### 0.0000 0.0000 1.0000 50.0000 1 0 Three
##### 0.0000 0.0000 1.0000 50.0000 1 0 Four
###### 0.0000 0.0000 1.0000 50.0000 0 0 Five
</pre>
<p><i>A sort of human</i>
</p>
<pre># 0.0000 0.0000 0.0000 0.0000 4 0 Root
## 0.0000 0.0000 1.5708 30.0000 0 0 Head
## 0.0000 0.0000 -1.5708 50.0000 2 0 Back
### 0.0000 0.0000 -0.7854 50.0000 1 0 LLeg
#### 0.0000 0.0000 0.7854 50.0000 0 0 LLeg2
### 0.0000 0.0000 0.7854 50.0000 1 0 RLeg
#### 0.0000 0.0000 -0.7854 50.0000 0 0 RLeg2
## 0.0000 0.0000 -0.1000 40.0000 1 0 LArm
### 0.0000 0.0000 0.1000 40.0000 0 0 LArm2
## 0.0000 0.0000 3.2416 40.0000 1 0 RArm
### 0.0000 0.0000 -0.1000 40.0000 0 0 RArm2
</pre>
<p>This is the function to read these files
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> Bone <span class="sy0">*</span>boneLoadStructure<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>path<span class="br0">)</span>
 <span class="br0">{</span>
 	Bone <span class="sy0">*</span>root<span class="sy0">,</span>		<span class="coMULTI">/* The root of the tree to load */</span>
 	     <span class="sy0">*</span>temp<span class="sy0">;</span>		<span class="coMULTI">/* A temporary root */</span>
&nbsp;
 	FILE <span class="sy0">*</span>file<span class="sy0">;</span>		<span class="coMULTI">/* File to load */</span>
&nbsp;
 	<span class="kw4">float</span> x<span class="sy0">,</span>		<span class="coMULTI">/* Bone data */</span>
 	      y<span class="sy0">,</span>
 	      angle<span class="sy0">,</span>
 	      length<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">int</span> depth<span class="sy0">,</span>		<span class="coMULTI">/* Depth retrieved from file */</span>
 	    actualLevel<span class="sy0">,</span>	<span class="coMULTI">/* Actual depth level */</span>
 	    flags<span class="sy0">;</span>		<span class="coMULTI">/* Bone flags */</span>
&nbsp;
 	<span class="kw4">char</span> name<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="sy0">,</span>		<span class="coMULTI">/* Buffers for strings */</span>
 	     depthStr<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="sy0">,</span>
 	     buffer<span class="br0">[</span><span class="nu0">512</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="br0">(</span>file <span class="sy0">=</span> <span class="kw3">fopen</span><span class="br0">(</span>path<span class="sy0">,</span> <span class="st0">"r"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"Can't open file&nbsp;%s for reading<span class="es1">\n</span>"</span><span class="sy0">,</span> path<span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw1">return</span> NULL<span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	root <span class="sy0">=</span> NULL<span class="sy0">;</span>
 	temp <span class="sy0">=</span> NULL<span class="sy0">;</span>
 	actualLevel <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span><span class="kw3">feof</span><span class="br0">(</span>file<span class="br0">)</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="coMULTI">/* Read a row from the file (I hope that 512 characters are sufficient for a row) */</span>
 		<span class="kw3">fgets</span><span class="br0">(</span>buffer<span class="sy0">,</span> <span class="nu0">512</span><span class="sy0">,</span> file<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Get the info about this bone*/</span>
 		<span class="kw3">sscanf</span><span class="br0">(</span>buffer<span class="sy0">,</span> <span class="st0">"%s&nbsp;%f&nbsp;%f&nbsp;%f&nbsp;%f&nbsp;%d&nbsp;%s<span class="es1">\n</span>"</span><span class="sy0">,</span> depthStr<span class="sy0">,</span> <span class="sy0">&amp;</span>x<span class="sy0">,</span> <span class="sy0">&amp;</span>y<span class="sy0">,</span> <span class="sy0">&amp;</span>angle<span class="sy0">,</span> <span class="sy0">&amp;</span>length<span class="sy0">,</span> <span class="sy0">&amp;</span>flags<span class="sy0">,</span> name<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Avoid empty strings, but this is ineffective for invalid strings */</span>
 		<span class="kw1">if</span> <span class="br0">(</span><span class="kw3">strlen</span><span class="br0">(</span>buffer<span class="br0">)</span> <span class="sy0">&lt;</span> <span class="nu0">3</span><span class="br0">)</span>
 			<span class="kw1">continue</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Calculate the depth */</span>
 		depth <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>depthStr<span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
 		<span class="kw1">if</span> <span class="br0">(</span>depth <span class="sy0">&lt;</span> <span class="nu0">0</span> <span class="sy0">||</span> depth <span class="sy0">&gt;</span> MAX_CHCOUNT<span class="br0">)</span>
 		<span class="br0">{</span>
 			<span class="kw3">fclose</span><span class="br0">(</span>file<span class="br0">)</span><span class="sy0">;</span>
 			<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"Wrong bone depth (%s)<span class="es1">\n</span>"</span><span class="sy0">,</span> depthStr<span class="br0">)</span><span class="sy0">;</span>
 			<span class="kw1">return</span> NULL<span class="sy0">;</span>
 		<span class="br0">}</span>
&nbsp;
 		<span class="coMULTI">/* If actual level is too high, go down */</span>
 		<span class="kw1">for</span> <span class="br0">(</span><span class="sy0">;</span> actualLevel <span class="sy0">&gt;</span> depth<span class="sy0">;</span> actualLevel<span class="sy0">--</span><span class="br0">)</span>
 			temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>parent<span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* If no root is defined, make one at level 0 */</span>
 		<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span>depth<span class="br0">)</span>
 		<span class="br0">{</span>
 			root <span class="sy0">=</span> boneAddChild<span class="br0">(</span>NULL<span class="sy0">,</span> x<span class="sy0">,</span> y<span class="sy0">,</span> angle<span class="sy0">,</span> length<span class="sy0">,</span> flags<span class="sy0">,</span> name<span class="br0">)</span><span class="sy0">;</span>
 			temp <span class="sy0">=</span> root<span class="sy0">;</span>
 		<span class="br0">}</span>
 		<span class="kw1">else</span>
 			temp <span class="sy0">=</span> boneAddChild<span class="br0">(</span>temp<span class="sy0">,</span> x<span class="sy0">,</span> y<span class="sy0">,</span> angle<span class="sy0">,</span> length<span class="sy0">,</span> flags<span class="sy0">,</span> name<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Since the boneAddChild returns child's address, we go up a level in the hierarchy */</span>
 		actualLevel<span class="sy0">++;</span>
 	<span class="br0">}</span>
&nbsp;
  	<span class="kw3">fclose</span><span class="br0">(</span>file<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">return</span> root<span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<h2> <span class="mw-headline" id="Drawing_the_skeleton_in_2D">Drawing the skeleton in 2D</span></h2>
<p>Now we should have working code which can create bones and a tree of bones, load skeletons from text files and free memory.
I think it's a waste of time to do more: since this work is done for video games, let's draw the skeleton on the screen! For this I'm using SDL and OpenGL: simple, fast and cross-platform.
Before starting the code, let's see how we can draw this structure:
</p>
<ul><li>Since each bone can be absolute or relative, we need to manage matrices to save/restore the status before a drawing
<ul><li>If a bone is relative to the parent, we have just to glTranslate it to draw the point and glRotate the current matrix.
</li><li>If a bone is absolute, we need to glPushMatrix, and when we need to draw another absolute bone, we need to glPopMatrix.
</li></ul>
</li></ul>
<p>As you can see, using angles and lengths is useful when drawing with OpenGL.
</p><p>Let's create the function boneDraw
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="coMULTI">/* TODO: Actually this doesn't handle absolute bones */</span>
 <span class="kw4">void</span> boneDraw<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	glPushMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Draw this bone
 	 * 1. Translate to coords
 	 * 2. Rotate the matrix
 	 * 3. Draw the line
 	 * 4. Reach the end position (translate again)
 	 */</span>
 	glTranslatef<span class="br0">(</span>root<span class="sy0">-&gt;</span>x<span class="sy0">,</span> root<span class="sy0">-&gt;</span>y<span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
 	glRotatef<span class="br0">(</span>RAD2DEG<span class="br0">(</span>root<span class="sy0">-&gt;</span>a<span class="br0">)</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glBegin<span class="br0">(</span>GL_LINES<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glColor3f<span class="br0">(</span><span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
 	glVertex2f<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
 	glColor3f<span class="br0">(</span><span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
 	glVertex2f<span class="br0">(</span>root<span class="sy0">-&gt;</span>l<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Translate to reach the new starting position */</span>
 	glTranslatef<span class="br0">(</span>root<span class="sy0">-&gt;</span>l<span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Call function on my children */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		boneDraw<span class="br0">(</span>root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glPopMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>And now let's create a new main to
</p>
<ol><li>Start SDL and OpenGL
</li><li>Load a skeleton file
</li><li>Draw it on the screen
</li></ol>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">int</span> argc<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">**</span>argv<span class="br0">)</span>
 <span class="br0">{</span>
 	SDL_Event sdlEv<span class="sy0">;</span>
 	Uint32 sdlVideoFlags <span class="sy0">=</span> SDL_OPENGL<span class="sy0">;</span>
 	Uint8 quit<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* We need one parameter: the structure file */</span>
 	<span class="kw1">if</span> <span class="br0">(</span>argc <span class="sy0">&lt;</span> <span class="nu0">2</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"This program require a filename as parameter<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw1">return</span> EXIT_FAILURE<span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* Initialize */</span>
 	<span class="kw1">if</span> <span class="br0">(</span>SDL_Init<span class="br0">(</span>SDL_INIT_VIDEO<span class="br0">)</span> <span class="sy0">&lt;</span> <span class="nu0">0</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"SDL_Init:&nbsp;%d<span class="es1">\n</span>"</span><span class="sy0">,</span> SDL_GetError<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw3">exit</span><span class="br0">(</span>EXIT_FAILURE<span class="br0">)</span><span class="sy0">;</span>
 	<span class="br0">}</span>
 	<span class="kw3">atexit</span><span class="br0">(</span>SDL_Quit<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Start graphic system with OGL */</span>
 	SDL_GL_SetAttribute<span class="br0">(</span>SDL_GL_RED_SIZE<span class="sy0">,</span> <span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
 	SDL_GL_SetAttribute<span class="br0">(</span>SDL_GL_GREEN_SIZE<span class="sy0">,</span> <span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
 	SDL_GL_SetAttribute<span class="br0">(</span>SDL_GL_BLUE_SIZE<span class="sy0">,</span> <span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
 	SDL_GL_SetAttribute<span class="br0">(</span>SDL_GL_DEPTH_SIZE<span class="sy0">,</span> <span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
 	SDL_GL_SetAttribute<span class="br0">(</span>SDL_GL_DOUBLEBUFFER<span class="sy0">,</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>SDL_SetVideoMode<span class="br0">(</span><span class="nu0">400</span><span class="sy0">,</span> <span class="nu0">400</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> sdlVideoFlags<span class="br0">)</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"SDL_SetVideoMode:&nbsp;%s<span class="es1">\n</span>"</span><span class="sy0">,</span> SDL_GetError<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw3">exit</span><span class="br0">(</span>EXIT_FAILURE<span class="br0">)</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	glShadeModel<span class="br0">(</span>GL_SMOOTH<span class="br0">)</span><span class="sy0">;</span>
 	glViewport<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">400</span><span class="sy0">,</span> <span class="nu0">400</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glMatrixMode<span class="br0">(</span>GL_PROJECTION<span class="br0">)</span><span class="sy0">;</span>
 	glOrtho<span class="br0">(</span><span class="sy0">-</span><span class="nu0">200</span><span class="sy0">,</span> <span class="nu0">200</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">200</span><span class="sy0">,</span> <span class="nu0">200</span><span class="sy0">,</span> <span class="sy0">-</span><span class="nu0">1</span><span class="sy0">,</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
 	glMatrixMode<span class="br0">(</span>GL_MODELVIEW<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Application Initialization */</span>
 	Bone <span class="sy0">*</span>root<span class="sy0">,</span> <span class="sy0">*</span>p<span class="sy0">;</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
 	root <span class="sy0">=</span> boneLoadStructure<span class="br0">(</span>argv<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Main loop */</span>
 	quit <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 	<span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span>quit<span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw1">while</span> <span class="br0">(</span>SDL_PollEvent<span class="br0">(</span><span class="sy0">&amp;</span>sdlEv<span class="br0">)</span><span class="br0">)</span>
 			<span class="kw1">switch</span> <span class="br0">(</span>sdlEv.<span class="me1">type</span><span class="br0">)</span>
 			<span class="br0">{</span>
 				<span class="kw1">case</span> SDL_QUIT<span class="sy0">:</span>
 					quit <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
 					<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
 				<span class="kw1">default</span><span class="sy0">:</span>
 					<span class="kw2">break</span><span class="sy0">;</span>
 			<span class="br0">}</span>
&nbsp;
 		glClear<span class="br0">(</span>GL_COLOR_BUFFER_BIT<span class="br0">)</span><span class="sy0">;</span>
 		glLoadIdentity<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		boneDraw<span class="br0">(</span>root<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		SDL_GL_SwapBuffers<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="kw1">return</span> EXIT_SUCCESS<span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Actually this code, applied to the three skeletons posted above (star, snake? and the humanoid), produces this result:
</p>
<center><a href="http://content.gpwiki.org/index.php/File:Bbs_star_grow_man.png" class="image" title="A star, a snake? and a humanoid figure to test this program"><img alt="A star, a snake? and a humanoid figure to test this program" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/Bbs_star_grow_man.png" width="600" height="212"></a></center>
<h2> <span class="mw-headline" id="Moving_the_structure">Moving the structure</span></h2>
<p>Once we have a puppet on the screen, it can be useful. If you are a programmer that can't wait to know everything before starting to code, maybe you already used it to create an animation (and it's possible, using frames, even without interpolation).
</p><p>Yes, you can do many things with just a bone, but if you have a puppet, you can do more knowing how to move it. And this is exactly what we'll do in the next step.
</p><p>Actually moving is simple (both in 2D and 3D), thanks to the hierarchy. I start by defining what we want to do with our puppet
</p>
<ul><li>Move the puppet around
</li><li>Select a bone
</li><li>Rotate a bone
</li><li>Change the length of a bone
</li><li>Set a degree of freedom for our bones
</li></ul>
<p>These are all easy things to do, so let's get started!
</p>
<h3> <span class="mw-headline" id="Moving_the_puppet_around">Moving the puppet around</span></h3>
<p>Moving is the easiest step (and of course important since usually you want to move objects and characters in your game&nbsp;;): we have a hierarchal structure, so moving the root bone (which is absolute) will move each child which is relatively positioned.
Since root is usually the topmost bone in the hierarchy, we don't have to locate it, just use the root pointer of our code.
</p><p>I want to click on the window with the left button of the mouse to move it in that position. To do this the code must handle the mouse event, then we can use the root pointer to access the root bone and change the puppet position.
Here's the code, which is short and goes in the SDL event handling loop:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw1">switch</span> <span class="br0">(</span>sdlEv.<span class="me1">type</span><span class="br0">)</span>
 <span class="br0">{</span>
 	...
&nbsp;
 	<span class="kw1">case</span> SDL_MOUSEBUTTONDOWN<span class="sy0">:</span>
 		<span class="kw1">if</span> <span class="br0">(</span>sdlEv.<span class="me1">button</span>.<span class="me1">button</span> <span class="sy0">==</span> SDL_BUTTON_LEFT<span class="br0">)</span>
 		<span class="br0">{</span>
			<span class="coMULTI">/* We have to translate the click since the
			 *  (0, 0) point is in the middle of the screen
			 * and we have to flip Y coords because in SDL
			 *  it grows inversely to the OpenGL
			 */</span>
 			root<span class="sy0">-&gt;</span>x <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">float</span><span class="br0">)</span>sdlEv.<span class="me1">button</span>.<span class="me1">x</span> <span class="sy0">-</span> <span class="nu16">200.0</span><span class="sy0">;</span>
 			root<span class="sy0">-&gt;</span>y <span class="sy0">=</span> <span class="nu16">200.0</span> <span class="sy0">-</span> <span class="br0">(</span><span class="kw4">float</span><span class="br0">)</span>sdlEv.<span class="me1">button</span>.<span class="me1">y</span><span class="sy0">;</span>
 		<span class="br0">}</span>
 		<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
 	...
 <span class="br0">}</span></pre></div></div>
<p>Finish&nbsp;:D It's simple, right? And it works (at least it works here&nbsp;:D).
You can already animate your puppet using frames, now that you know how to move it in the space.
</p>
<h3> <span class="mw-headline" id="Selecting_a_bone">Selecting a bone</span></h3>
<p>Before rotating a bone, you need to select it. The way it's selected isn't important itself, but there are some things you must know
</p>
<ul><li>Each bone must be uniquely identified in the hierarchy
</li></ul>
<p>Selecting is an operation on the tree, so there are many ways to find your bone. Actually I use a very simple recursive function (which isn't optimized for speed. If you are interested in high-speed you must know very well the tree data structure, and this is not the topic), which returns a pointer to the bone.
In this tutorial - for now - we use a unique name to identify a bone, this is for clarity when you dump the bones, but actually in your game you may prefer to use a numeric ID for each bone - which is faster and require less memory.
</p><p>We define a selecting function which, given the bone name, returns a pointer to that bone.
The code is simple as you can see
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> Bone <span class="sy0">*</span>boneFindByName<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
 	Bone <span class="sy0">*</span>p<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* No bone */</span>
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root<span class="br0">)</span>
 		<span class="kw1">return</span> NULL<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Check this name */</span>
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="kw3">strcmp</span><span class="br0">(</span>root<span class="sy0">-&gt;</span>name<span class="sy0">,</span> name<span class="br0">)</span><span class="br0">)</span>
 		<span class="kw1">return</span> root<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="coMULTI">/* Search recursively */</span>
 		p <span class="sy0">=</span> boneFindByName<span class="br0">(</span>root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> name<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Found a bone in this subtree! */</span>
 		<span class="kw1">if</span> <span class="br0">(</span>p<span class="br0">)</span>
 			<span class="kw1">return</span> p<span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* No such bone */</span>
 	<span class="kw1">return</span> NULL<span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>But to be honest - since using names is a little complex compared to using numbers - we also need something to help us list each bone, so that we can always know the previous and the next bone in the tree.
I created this function, which fills a NULL terminated array of strings.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="co2">#define MAX_BONECOUNT			20</span>
&nbsp;
 <span class="kw4">void</span> boneListNames<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="sy0">,</span> <span class="kw4">char</span> names<span class="br0">[</span>MAX_BONECOUNT<span class="br0">]</span><span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">,</span>
 		present<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root<span class="br0">)</span>
 		<span class="kw1">return</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Check if this name is already in the list */</span>
 	present <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">(</span>i <span class="sy0">&lt;</span> MAX_BONECOUNT<span class="br0">)</span> <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>names<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">!=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="br0">)</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="kw3">strcmp</span><span class="br0">(</span>names<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>name<span class="br0">)</span><span class="br0">)</span>
 		<span class="br0">{</span>
 			present <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
 			<span class="kw2">break</span><span class="sy0">;</span>
 		<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* If itsn't present and if there is space in list */</span>
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>present <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>i <span class="sy0">&lt;</span> MAX_BONECOUNT<span class="br0">)</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">strcpy</span><span class="br0">(</span>names<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>name<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">+</span> <span class="nu0">1</span> <span class="sy0">&lt;</span> MAX_BONECOUNT<span class="br0">)</span>
 			names<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* Now fill the list with subtree's names */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		boneListNames<span class="br0">(</span>root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> names<span class="br0">)</span><span class="sy0">;</span>		
 <span class="br0">}</span></pre></div></div>
<p>And then I created and filled that array in main
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">char</span> names<span class="br0">[</span>MAX_BONECOUNT<span class="br0">]</span><span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="sy0">;</span>
 names<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="sy0">;</span>
&nbsp;
 boneListNames<span class="br0">(</span>root<span class="sy0">,</span> names<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 <span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">(</span>i <span class="sy0">&lt;</span> MAX_BONECOUNT<span class="br0">)</span> <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>names<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">!=</span> <span class="st0">'<span class="es5">\0</span>'</span><span class="br0">)</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Bone name:&nbsp;%s<span class="es1">\n</span>"</span><span class="sy0">,</span> names<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Now that we can actually find a bone by name and we know all the bones, just handle with SDL two keys that allow us to loop through the bones. I'll use N(ext) and P(rev) keys of the keyboard to be vim editor friendly. If you want, you can also use the mouse wheel.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> 	<span class="coMULTI">/* As global */</span>
 	<span class="kw4">char</span> <span class="sy0">*</span>currentName <span class="sy0">=</span> NULL<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* In main */</span>
 	<span class="kw4">int</span> nameIndex <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 	<span class="coMULTI">/* Calling boneListNames */</span>
 	currentName <span class="sy0">=</span> names<span class="br0">[</span>nameIndex<span class="br0">]</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* In SDL event handling loop */</span>
 	<span class="kw1">case</span> SDL_KEYDOWN<span class="sy0">:</span>
 		<span class="kw1">switch</span> <span class="br0">(</span>sdlEv.<span class="me1">key</span>.<span class="me1">keysym</span>.<span class="me1">sym</span><span class="br0">)</span>
 		<span class="br0">{</span>
 			<span class="kw1">case</span> SDLK_n<span class="sy0">:</span>
 				<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>nameIndex <span class="sy0">&lt;</span> MAX_BONECOUNT<span class="br0">)</span> <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>names<span class="br0">[</span>nameIndex<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span>
 					nameIndex<span class="sy0">++;</span>
 				<span class="kw1">else</span>
 					nameIndex <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 				<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
 			<span class="kw1">case</span> SDLK_p<span class="sy0">:</span>
 				<span class="kw1">if</span> <span class="br0">(</span>nameIndex <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span>
 					nameIndex<span class="sy0">--;</span>
 				<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
 			<span class="kw1">default</span><span class="sy0">:</span>
 				<span class="kw2">break</span><span class="sy0">;</span>
 		<span class="br0">}</span>
 		currentName <span class="sy0">=</span> names<span class="br0">[</span>nameIndex<span class="br0">]</span><span class="sy0">;</span>
 		<span class="kw2">break</span><span class="sy0">;</span></pre></div></div>
<p>And of course, it would be nice to add some color to our drawing, so that when a bone is selected it is drawn with different colors, so using the currentName value, we modify the boneDraw function
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> ...
 <span class="me1">glBegin</span><span class="br0">(</span>GL_LINES<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="kw3">strcmp</span><span class="br0">(</span>root<span class="sy0">-&gt;</span>name<span class="sy0">,</span> currentName<span class="br0">)</span><span class="br0">)</span>
 	glColor3f<span class="br0">(</span><span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="kw1">else</span>
 	glColor3f<span class="br0">(</span><span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 glVertex2f<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 <span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="kw3">strcmp</span><span class="br0">(</span>root<span class="sy0">-&gt;</span>name<span class="sy0">,</span> currentName<span class="br0">)</span><span class="br0">)</span>
 	glColor3f<span class="br0">(</span><span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="kw1">else</span>
 	glColor3f<span class="br0">(</span><span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 glVertex2f<span class="br0">(</span>root<span class="sy0">-&gt;</span>l<span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 ...</pre></div></div>
<p>Now everything should be ok. As you see, this is a long process, but not to complex. Of course it's better to use numbers as bone's ID, so that you don't need to keep track of the current bone name and you don't need a function to list all the names - just get the min and max ID in the tree.
</p>
<h3> <span class="mw-headline" id="Rotating_a_bone">Rotating a bone</span></h3>
<p>Well, this is the hot point: rotating a bone is the most common action when handling a puppet, so this is import, but it's very simple.
Since we have the name of the currently selected bone, we just have to use the boneFindByName function to retrieve a pointer to that bone, then just modify it's angle value.
</p><p>This is done again in the event loop, with very few lines of code. To change the angle i use the left and right buttons of the keyboard.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw1">case</span> SDLK_LEFT<span class="sy0">:</span>
 	p <span class="sy0">=</span> boneFindByName<span class="br0">(</span>root<span class="sy0">,</span> currentName<span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw1">if</span> <span class="br0">(</span>p<span class="br0">)</span>
 		p<span class="sy0">-&gt;</span>a <span class="sy0">+=</span> <span class="nu16">0.1</span><span class="sy0">;</span>
 	<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
 <span class="kw1">case</span> SDLK_RIGHT<span class="sy0">:</span>
 	p <span class="sy0">=</span> boneFindByName<span class="br0">(</span>root<span class="sy0">,</span> currentName<span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw1">if</span> <span class="br0">(</span>p<span class="br0">)</span>
 		p<span class="sy0">-&gt;</span>a <span class="sy0">-=</span> <span class="nu16">0.1</span><span class="sy0">;</span>
 	<span class="kw2">break</span><span class="sy0">;</span></pre></div></div>
<h3> <span class="mw-headline" id="Changing_length_of_a_bone">Changing length of a bone</span></h3>
<p>Like above, this is a simple action: bind two keys for this function (I use up and down), then get the current bone and change the bone's length.
The code is simple, as always&nbsp;;)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw1">case</span> SDLK_UP<span class="sy0">:</span>
 	p <span class="sy0">=</span> boneFindByName<span class="br0">(</span>root<span class="sy0">,</span> currentName<span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw1">if</span> <span class="br0">(</span>p<span class="br0">)</span>
 		p<span class="sy0">-&gt;</span>l <span class="sy0">+=</span> <span class="nu16">0.1</span><span class="sy0">;</span>
 	<span class="kw2">break</span><span class="sy0">;</span>
&nbsp;
 <span class="kw1">case</span> SDLK_DOWN<span class="sy0">:</span>
 	p <span class="sy0">=</span> boneFindByName<span class="br0">(</span>root<span class="sy0">,</span> currentName<span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw1">if</span> <span class="br0">(</span>p<span class="br0">)</span>
 		p<span class="sy0">-&gt;</span>l <span class="sy0">-=</span> <span class="nu16">0.1</span><span class="sy0">;</span>
 	<span class="kw2">break</span><span class="sy0">;</span></pre></div></div>
<h3> <span class="mw-headline" id="Set_a_degree_of_freedom_for_our_bones">Set a degree of freedom for our bones</span></h3>
<p>Now, let's add something to our bones: a degree of freedom. This is not really useful if the animation is done with Forward Kinematic, since you have to move each bone - which you can do with the command we just put in the game.
If you are using inverse kinematic, or if the user has control of the bones, you may want to add some control to the bone rotations.
So, we just have to specify a limit for the angle. We just have to put:
</p>
<pre>float minAngle, maxAngle;
</pre>
<p>in the bone structure, and then check their values before changing the bone angles.
</p><p>This is really simple, you could probably do it by yourself or just look at the tutorial sources (TODO when they're ready&nbsp;;)
</p><p>Below you can see an image showing a limited movement of a 2D bone
</p>
<center><a href="http://content.gpwiki.org/index.php/File:Bbs_degree_freedom.png" class="image"><img alt="Bbs degree freedom.png" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/Bbs_degree_freedom.png" width="230" height="240"></a></center>
<h2> <span class="mw-headline" id="Animating">Animating</span></h2>
<p>Animating means "giving life". So, let's give life to our skeletal structure&nbsp;:)
As I said before, we need two basic concepts:
</p>
<ul><li>Keyframes
</li><li>Interpolation
</li></ul>
<h3> <span class="mw-headline" id="Keyframes">Keyframes</span></h3>
<p>A keyframe literally means a frame which contains a key. Well, suppose you have a time line for your animation: a keyframe represents a special key where the animation changes in a particular way.
For example, you want to animate the weaving action, with your hand open that is moved from left to right.
The first keyframe (let's say the frame number 0) is your hand on the left which starts to move toward the right. The second keyframe (frame number 5) is your hand on the right, and the last keyframe (frame number 10) is again your hand on the left.
As you can see, these frames are "key" since at these points the movement changes radically: between frames 0 and 1, the body status changes from stopped to in movement position.
Between frames n and n+1, with 1 &lt;= n &lt; 4 the animation don't change so much, because if you take frame 1 and frame 2, the hand is a little moved to the right. Same with frames 3, 4 and 4, 5.
Then, with frames 5 and 6, there is another change in the animation, since your hand stops to move toward right and starts to move to left.
And finally at frame 10, the animation changes again because your hand stops.
</p><p>So, a keyframe is a particular status at time T in your animation, which means a particular change in the animation course.
</p><p>In our code, keyframes can be implemented using a Keyframe structure, which keeps track of bone status at a specific time.
An animation will be just an array of keyframes:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">typedef</span> <span class="kw4">struct</span>
 <span class="br0">{</span>
 	<span class="kw4">uint32_t</span> <span class="kw3">time</span><span class="sy0">;</span>
 	<span class="kw4">float</span> angle<span class="br0">[</span>MAX_BONECOUNT<span class="br0">]</span><span class="sy0">,</span>
 		  length<span class="br0">[</span>MAX_BONECOUNT<span class="br0">]</span><span class="sy0">;</span>
 <span class="br0">}</span> Keyframe<span class="sy0">;</span></pre></div></div>
<p>Where 
</p>
<ul><li>time is an hi-resolution (millisec) counter that tell us at which time the keyframe occur.
</li><li>angle contains the actual angle for each bone in out skeleton
</li><li>length contains the length for each bone in our structure
</li></ul>
<p>Of course, if your animation don't allow stretching of bones, you can omit the length array to avoid waste of memory.
Also, you may prefer to use lists or other forms of data storage instead of arrays, if your game allows high number of bones but lots of models don't reach that number - for instance: if you have 1 human in your game which have 100 bones, and you have 200 enemies which uses 10 bones each, using a float[100] is a great waste of memory since 200/201 characters uses only 10/100 fields of the array.
In this case you can use a linked list like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">typedef</span> <span class="kw4">struct</span> _KeyData
 <span class="br0">{</span>
 	<span class="kw4">float</span> angle<span class="sy0">,</span> length<span class="sy0">;</span>
 	<span class="kw4">struct</span> _KeyData <span class="sy0">*</span>next<span class="sy0">;</span>
 <span class="br0">}</span> KeyData<span class="sy0">;</span>
&nbsp;
 <span class="kw4">typedef</span> <span class="kw4">struct</span>
 <span class="br0">{</span>
 	<span class="kw4">uint32_t</span> <span class="kw3">time</span><span class="sy0">;</span>
 	KeyData <span class="sy0">*</span>first<span class="sy0">;</span>
 <span class="br0">}</span> Keyframe<span class="sy0">;</span></pre></div></div>
<p>Which is a good solution. Of course in this tutorial I won't use this to keep code simple, also because I intend to use only a skeleton at time in the application, and since - also having some skeletons at the same time - the memory waste is acceptable.
</p><p>Some programmers also like to link each keyframe to a bone, like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">typedef</span> <span class="kw4">struct</span>
<span class="br0">{</span>
	<span class="kw4">uint32_t</span> <span class="kw3">time</span><span class="sy0">;</span>
	<span class="kw4">float</span> angle<span class="sy0">,</span> length<span class="sy0">;</span>
<span class="br0">}</span> Keyframe<span class="sy0">;</span>
&nbsp;
<span class="kw4">typedef</span> <span class="kw4">struct</span>
<span class="br0">{</span>
	<span class="kw4">uint32_t</span> id<span class="sy0">;</span>
	<span class="kw4">float</span> x<span class="sy0">,</span> y<span class="sy0">,</span> a<span class="sy0">,</span> l<span class="sy0">;</span>
&nbsp;
	Keyframe <span class="sy0">*</span>animation<span class="sy0">;</span>
<span class="br0">}</span> Bone<span class="sy0">;</span></pre></div></div>
<p>This is a good technique, since it allow to:
</p>
<dl><dt> Use bone-related keyframes, and not skeletal-related
</dt><dd> I take as example the waving hand: you have - just to say - 6 bones: 1 arm bone and 5 bones for fingers. If your animation don't move fingers, using this technique avoid you to save, at each keyframe, status for each bone, instead of the entire skeleton. So, in our case, each finger will be a fixed angle value and don't have related Keyframes, while the arm bone will have 3 keyframes.
</dd><dt> Speed up the calculations
</dt><dd> When a keyframe happen, you don't have to refresh the whole tree (in our example you have only to refresh the arm bone), and when you have to refresh each bone, this allow you to doing this in the drawing routine, without involving an additional find-and-refresh function, that could make the code run slower.
</dd></dl>
<p>So, it's a good idea to use keyframes like this, since the previous model is good only for explanations&nbsp;:D
But if you find good reasons to use the skeletal-related model, please tell us!
</p><p>Also remember that you may want to change vertexes positions during the animation, so in your Keyframe structure, in addition to angle and length fields, you may want to modify the coords values. The procedure is always the same, I'm just showing it for angles and lengths, it's up to you to understand what fields you need in your application.
</p>
<h3> <span class="mw-headline" id="Interpolation">Interpolation</span></h3>
<p>Before I said that with boned animation, you don't have to store all the frames of your animation, but just the keyframes.
Alright, now we know what a keyframe is, but the question is: if I've only keyframes, how can I animate the skeleton?
The answer is: calculating the other frames using interpolation (or linear interpolation, to be more precise).
</p><p>Keyframes represent a big change in our animation, but other frames don't! This mean that we can guess - knowing some starting conditions - frames between two keyframes. Our guess is done by interpolating the keyframes.
</p><p>Different interpolation algorithms exist, and in some cases you may prefer to use one instead of another.
For example, if you know that your animation starts slow to get faster, you may prefer to use a exponential interpolation, or if you know that your animation starts slow, get velocity and then return to get slower, you may want to use a sine interpolation.
But in the common case, we prefer to use linear interpolation, that means that our animation don't change speed: waving an hand with linear interpolation produces that at every frame our hand will rotate for X degrees, and between frames X don't change.
To be more precise, a *real* waving action will be more like a sine interpolation, since our hand tend to accelerate and decelerate when we change direction - since our hand have some mass that we have to contrast with our muscles.
</p><p>In this tutorial - and most of games - linear interpolation is good: it provides a good approximation and a good executing speed.
</p><p>Linear interpolation is quite simple to realize, here a very simple example:
</p>
<ul><li>Imagine you have a bone B, starting with angle a=0° at time t=0.
</li><li>The animation of B ends on time t=10 and angle a=180°.
</li><li>The animation runs at 12fpt (frame per time), that is between t=0 and t=1 12 frames are drawn
</li><li>To calculate linear interpolation, we have just to calculate the difference between each frame
</li></ul>
<pre>(180 - 0) / (10 * 12 - 0 * 12) = 180 / 120 = 1.5°
</pre>
<ul><li>This means that at every frame, our bone have to rotate 1.5° respect the previous frame.
</li></ul>
<h3> <span class="mw-headline" id="Coding">Coding</span></h3>
<p>Well, before starting to code, it's a good idea to prepare all the tools you need to develop.
So, to create an animation, we need to have something that export the animation.
In our case we can use this same demo to create an animation: since we can actually load a model, and move the bones, we just have to allow the exporting of frames.
</p><p>Since we have the boneDumpTree function, we just call it every time the user asks, pressing the key 'd' on the keyboard. In this way, you can load a model and create the sequence of keyframe you need for the animation.
</p><p>I just added few lines to the event handler loop
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw1">case</span> SDLK_d<span class="sy0">:</span>
 	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"[FRAME]<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
 	boneDumpTree<span class="br0">(</span>root<span class="sy0">,</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw2">break</span><span class="sy0">;</span></pre></div></div>
<p>Now we have just to code our knowledge.
</p><p>I'll adopt the bone-related keyframe model, since it have many advantages over the skeleton-related one.
Also I'll add some fields in our Bone structure - in addition to the keyframes ones - to keep track of the change between two frames, to avoid more calculations than what's necessary.
</p><p>So, let's restyle our Bone structure
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">typedef</span> <span class="kw4">struct</span>
 <span class="br0">{</span>
 	Uint32 <span class="kw3">time</span><span class="sy0">;</span>
 	<span class="kw4">float</span> angle<span class="sy0">,</span> length<span class="sy0">;</span>
 <span class="br0">}</span> Keyframe<span class="sy0">;</span>
&nbsp;
 <span class="kw4">typedef</span> <span class="kw4">struct</span> _Bone
 <span class="br0">{</span>
 	<span class="kw4">char</span> name<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="sy0">;</span>			<span class="coMULTI">/* Remember to prefer numeric IDs */</span>
 	<span class="kw4">float</span> x<span class="sy0">,</span>
 		y<span class="sy0">,</span>
 		a<span class="sy0">,</span>
 		l<span class="sy0">,</span>
 		offA<span class="sy0">,</span>				<span class="coMULTI">/* Offsets measures for angle and length */</span>
 		offL<span class="sy0">;</span>
&nbsp;
 	Uint8 flags<span class="sy0">,</span>
 		childCount<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">struct</span> _Bone <span class="sy0">*</span>child<span class="br0">[</span>MAX_CHCOUNT<span class="br0">]</span><span class="sy0">,</span>
 				<span class="sy0">*</span>parent<span class="sy0">;</span>
&nbsp;
 	Uint32 keyframeCount<span class="sy0">;</span>	<span class="coMULTI">/* Number of keyframes */</span>
 	Keyframe keyframe<span class="br0">[</span>MAX_KFCOUNT<span class="br0">]</span><span class="sy0">;</span>	<span class="coMULTI">/* Animation for this bone */</span>
 <span class="br0">}</span> Bone<span class="sy0">;</span></pre></div></div>
<p>The structure is done and ready for animation. Now we have to code
</p>
<ul><li>A function to read an animation file
</li><li>A function that animate the model
</li></ul>
<p>To save and load animation files, we can modify the boneDumpTree and boneLoadStructure functions:
</p>
<ul><li>boneDumpTree can append to each row, a list of 3 values: time, angle and length, for each keyframe
</li><li>boneLoadStructure read each row, as before, but in addition if it finds other info, use them as keyframe
</li></ul>
<p>Of course I use this technique because I can create, understand and manage animation files just with ASCII files, but in a game you should write bits instead of strings, and of course create better algorithms to handle save and load.
</p><p>So, here the modified version of the boneDumpTree
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> boneDumpTree<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="sy0">,</span> Uint8 level<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root<span class="br0">)</span>
 		<span class="kw1">return</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> level<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"#"</span><span class="br0">)</span><span class="sy0">;</span> <span class="coMULTI">/* We print # to signal the level of this bone. */</span>
&nbsp;
 	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"&nbsp;%4.4f&nbsp;%4.4f&nbsp;%4.4f&nbsp;%4.4f&nbsp;%d&nbsp;%s"</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>x<span class="sy0">,</span> root<span class="sy0">-&gt;</span>y<span class="sy0">,</span> root<span class="sy0">-&gt;</span>a<span class="sy0">,</span> root<span class="sy0">-&gt;</span>l<span class="sy0">,</span> root<span class="sy0">-&gt;</span>flags<span class="sy0">,</span> root<span class="sy0">-&gt;</span>name<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Now print animation info */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>keyframeCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"&nbsp;%d&nbsp;%4.4f&nbsp;%4.4f"</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i<span class="br0">]</span>.<span class="kw3">time</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">angle</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">length</span><span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Recursively call this on my children */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		boneDumpTree<span class="br0">(</span>root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> level <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>And now let's define the boneLoadStructure function, which load these info.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> Bone <span class="sy0">*</span>boneLoadStructure<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>path<span class="br0">)</span>
 <span class="br0">{</span>
 	Bone <span class="sy0">*</span>root<span class="sy0">,</span>
 		 <span class="sy0">*</span>temp<span class="sy0">;</span>
&nbsp;
 	FILE <span class="sy0">*</span>file<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">float</span> x<span class="sy0">,</span>
 		  y<span class="sy0">,</span>
 		  angle<span class="sy0">,</span>
 		  length<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">int</span> unusedChildrenCount<span class="sy0">,</span>
 		depth<span class="sy0">,</span>
 		actualLevel<span class="sy0">,</span>
 		flags<span class="sy0">,</span>
 		count<span class="sy0">;</span>
&nbsp;
 	Uint32 <span class="kw3">time</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw4">char</span> name<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="sy0">,</span>
 		 depthStr<span class="br0">[</span><span class="nu0">20</span><span class="br0">]</span><span class="sy0">,</span>
 		 animBuf<span class="br0">[</span><span class="nu0">1024</span><span class="br0">]</span><span class="sy0">,</span>
 		 buffer<span class="br0">[</span><span class="nu0">1024</span><span class="br0">]</span><span class="sy0">,</span>
 		 <span class="sy0">*</span>ptr<span class="sy0">,</span>
 		 <span class="sy0">*</span>token<span class="sy0">;</span>
&nbsp;
 	Keyframe <span class="sy0">*</span>k<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span><span class="br0">(</span>file <span class="sy0">=</span> <span class="kw3">fopen</span><span class="br0">(</span>path<span class="sy0">,</span> <span class="st0">"r"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"Can't open file&nbsp;%s for reading<span class="es1">\n</span>"</span><span class="sy0">,</span> path<span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw1">return</span> NULL<span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	root <span class="sy0">=</span> NULL<span class="sy0">;</span>
 	temp <span class="sy0">=</span> NULL<span class="sy0">;</span>
 	actualLevel <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">while</span> <span class="br0">(</span><span class="sy0">!</span><span class="kw3">feof</span><span class="br0">(</span>file<span class="br0">)</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">memset</span><span class="br0">(</span>animBuf<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">1024</span><span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw3">fgets</span><span class="br0">(</span>buffer<span class="sy0">,</span> <span class="nu0">1024</span><span class="sy0">,</span> file<span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw3">sscanf</span><span class="br0">(</span>buffer<span class="sy0">,</span> <span class="st0">"%s&nbsp;%f&nbsp;%f&nbsp;%f&nbsp;%f&nbsp;%d&nbsp;%d&nbsp;%s&nbsp;%[^<span class="es1">\n</span>]"</span><span class="sy0">,</span> depthStr<span class="sy0">,</span> <span class="sy0">&amp;</span>x<span class="sy0">,</span> <span class="sy0">&amp;</span>y<span class="sy0">,</span>
                       <span class="sy0">&amp;</span>angle<span class="sy0">,</span> <span class="sy0">&amp;</span>length<span class="sy0">,</span> <span class="sy0">&amp;</span>flags<span class="sy0">,</span> <span class="sy0">&amp;</span>unusedChildrenCount<span class="sy0">,</span> name<span class="sy0">,</span> animBuf<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Avoid empty strings */</span>
 		<span class="kw1">if</span> <span class="br0">(</span><span class="kw3">strlen</span><span class="br0">(</span>buffer<span class="br0">)</span> <span class="sy0">&lt;</span> <span class="nu0">3</span><span class="br0">)</span>
 			<span class="kw1">continue</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Calculate the depth */</span>
 		depth <span class="sy0">=</span> <span class="kw3">strlen</span><span class="br0">(</span>depthStr<span class="br0">)</span> <span class="sy0">-</span> <span class="nu0">1</span><span class="sy0">;</span>
 		<span class="kw1">if</span> <span class="br0">(</span>depth <span class="sy0">&lt;</span> <span class="nu0">0</span> <span class="sy0">||</span> depth <span class="sy0">&gt;</span> MAX_CHCOUNT<span class="br0">)</span>
 		<span class="br0">{</span>
 			<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"Wrong bone depth (%s)<span class="es1">\n</span>"</span><span class="sy0">,</span> depthStr<span class="br0">)</span><span class="sy0">;</span>
 			<span class="kw1">return</span> NULL<span class="sy0">;</span>
 		<span class="br0">}</span>
&nbsp;
 		<span class="kw1">for</span> <span class="br0">(</span><span class="sy0">;</span> actualLevel <span class="sy0">&gt;</span> depth<span class="sy0">;</span> actualLevel<span class="sy0">--</span><span class="br0">)</span>
 			temp <span class="sy0">=</span> temp<span class="sy0">-&gt;</span>parent<span class="sy0">;</span>
&nbsp;
 		<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span>depth<span class="br0">)</span>
 		<span class="br0">{</span>
 			root <span class="sy0">=</span> boneAddChild<span class="br0">(</span>NULL<span class="sy0">,</span> x<span class="sy0">,</span> y<span class="sy0">,</span> angle<span class="sy0">,</span> length<span class="sy0">,</span> flags<span class="sy0">,</span> name<span class="br0">)</span><span class="sy0">;</span>
 			temp <span class="sy0">=</span> root<span class="sy0">;</span>
 		<span class="br0">}</span>
 		<span class="kw1">else</span>
 			temp <span class="sy0">=</span> boneAddChild<span class="br0">(</span>temp<span class="sy0">,</span> x<span class="sy0">,</span> y<span class="sy0">,</span> angle<span class="sy0">,</span> length<span class="sy0">,</span> flags<span class="sy0">,</span> name<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Now check for animation data */</span>
 		<span class="kw1">if</span> <span class="br0">(</span><span class="kw3">strlen</span><span class="br0">(</span>animBuf<span class="br0">)</span> <span class="sy0">&gt;</span> <span class="nu0">3</span><span class="br0">)</span>
 		<span class="br0">{</span>
 			ptr <span class="sy0">=</span> animBuf<span class="sy0">;</span>
 			<span class="kw1">while</span> <span class="br0">(</span><span class="br0">(</span>token <span class="sy0">=</span> <span class="kw3">strtok</span><span class="br0">(</span>ptr<span class="sy0">,</span> <span class="st0">" "</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 			<span class="br0">{</span>
 				ptr <span class="sy0">=</span> NULL<span class="sy0">;</span>
 				<span class="kw3">time</span> <span class="sy0">=</span> <span class="kw3">atoi</span><span class="br0">(</span>token<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 				token <span class="sy0">=</span> <span class="kw3">strtok</span><span class="br0">(</span>ptr<span class="sy0">,</span> <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
 				angle <span class="sy0">=</span> <span class="kw3">atof</span><span class="br0">(</span>token<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 				token <span class="sy0">=</span> <span class="kw3">strtok</span><span class="br0">(</span>ptr<span class="sy0">,</span> <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
 				length <span class="sy0">=</span> <span class="kw3">atof</span><span class="br0">(</span>token<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 				<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Read&nbsp;%d&nbsp;%f&nbsp;%f<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="kw3">time</span><span class="sy0">,</span> angle<span class="sy0">,</span> length<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 				<span class="kw1">if</span> <span class="br0">(</span>temp<span class="sy0">-&gt;</span>keyframeCount <span class="sy0">&gt;=</span> MAX_KFCOUNT<span class="br0">)</span>
 				<span class="br0">{</span>
 					<span class="kw3">fprintf</span><span class="br0">(</span>stderr<span class="sy0">,</span> <span class="st0">"Can't add more keyframes<span class="es1">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
 					<span class="kw1">continue</span><span class="sy0">;</span>
 				<span class="br0">}</span>
&nbsp;
 				k <span class="sy0">=</span> <span class="sy0">&amp;</span><span class="br0">(</span>temp<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>temp<span class="sy0">-&gt;</span>keyframeCount<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 				k<span class="sy0">-&gt;</span><span class="kw3">time</span> <span class="sy0">=</span> <span class="kw3">time</span><span class="sy0">;</span>
 				k<span class="sy0">-&gt;</span>angle <span class="sy0">=</span> angle<span class="sy0">;</span>
 				k<span class="sy0">-&gt;</span>length <span class="sy0">=</span> length<span class="sy0">;</span>
&nbsp;
 				temp<span class="sy0">-&gt;</span>keyframeCount<span class="sy0">++;</span>
 			<span class="br0">}</span>
 		<span class="br0">}</span>
&nbsp;
 		actualLevel<span class="sy0">++;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="kw1">return</span> root<span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Finally, we have to animate the bone. The animation I made is simple:
</p>
<ul><li>A flag determine if I should animate or not
</li><li>If I should, check the current time
<ul><li>If this is a keyframe, I should calculate the offsets using the interpolation
</li><li>If the actual frame isn't a key, I should just change the actual angle/length
</li><li>If this is the last keyframe, start from beginning
</li></ul>
</li><li>Draw normally using the x, y, a, l values stored in the bone structure
</li></ul>
<p>To do this, we need to add a flag in the code:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">int</span> animating<span class="sy0">;</span>
&nbsp;
 <span class="coMULTI">/* Start/end animation */</span>
 <span class="kw1">case</span> SDLK_a<span class="sy0">:</span>
 	animating <span class="sy0">=</span> <span class="sy0">!</span>animating<span class="sy0">;</span>
 	<span class="kw2">break</span><span class="sy0">;</span></pre></div></div>
<p>And then we should add something that handle the current frame state. To update the state we have to visit the entire tree, check for the actual state, calculate the interpolation and update the bone values.
</p><p>The following function, take the root element and the actual time. Then, it checks if the actual time correspond to any of the keyframes. If it is, calculate the interpolation between frames and animate the bones.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> boneAnimate<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="sy0">,</span> <span class="kw4">int</span> <span class="kw3">time</span><span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">float</span> ang<span class="sy0">,</span>
 		  len<span class="sy0">,</span>
 		  tim<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Check for keyframes */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>keyframeCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>			
 		<span class="kw1">if</span> <span class="br0">(</span>root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i<span class="br0">]</span>.<span class="kw3">time</span> <span class="sy0">==</span> <span class="kw3">time</span><span class="br0">)</span>
 		<span class="br0">{</span>
 			<span class="coMULTI">/* Find the index for the interpolation */</span>
 			<span class="kw1">if</span> <span class="br0">(</span>i <span class="sy0">!=</span> root<span class="sy0">-&gt;</span>keyframeCount <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">)</span>
 			<span class="br0">{</span>
 				tim <span class="sy0">=</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span>.<span class="kw3">time</span> <span class="sy0">-</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i<span class="br0">]</span>.<span class="kw3">time</span><span class="sy0">;</span>
 				ang <span class="sy0">=</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span>.<span class="me1">angle</span> <span class="sy0">-</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">angle</span><span class="sy0">;</span>
 				len <span class="sy0">=</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">]</span>.<span class="me1">length</span> <span class="sy0">-</span> root<span class="sy0">-&gt;</span>keyframe<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">length</span><span class="sy0">;</span>
&nbsp;
 				root<span class="sy0">-&gt;</span>offA <span class="sy0">=</span> ang <span class="sy0">/</span> tim<span class="sy0">;</span>
 				root<span class="sy0">-&gt;</span>offL <span class="sy0">=</span> len <span class="sy0">/</span> tim<span class="sy0">;</span>
  			<span class="br0">}</span>
 			<span class="kw1">else</span>
 			<span class="br0">{</span>
 				root<span class="sy0">-&gt;</span>offA <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 				root<span class="sy0">-&gt;</span>offL <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 			<span class="br0">}</span>
 		<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* Change animation */</span>
 	root<span class="sy0">-&gt;</span>a <span class="sy0">+=</span> root<span class="sy0">-&gt;</span>offA<span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>l <span class="sy0">+=</span> root<span class="sy0">-&gt;</span>offL<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Call on other bones */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		boneAnimate<span class="br0">(</span>root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">,</span> <span class="kw3">time</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>To call this function in the main i added
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw1">if</span> <span class="br0">(</span>animating<span class="br0">)</span>
 	boneAnimate<span class="br0">(</span>root<span class="sy0">,</span> frameNum<span class="sy0">++</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Note that the frameNum counter is incremented only if the animation is active. This allow us to stop the animation and restart when we stopped.
</p>
<h2> <span class="mw-headline" id="Simple_polygon_skinning">Simple polygon skinning</span></h2>
<p>So we are finally to the skinning section... probably you got tired with working only with bones, and you may see some substance&nbsp;:D
</p><p>As I said at the beginning, one of the advantages of the skeletal animation is that you have a skeleton which can move, and you can apply a mesh on it to make the mesh follow it's movement.
This is great - for example - if you intend to subdivide the development of the game through a team of people: programmers program how the game interact with the bones, while graphics can draw characters meshes.
</p><p>Of course skinning is great also for modding: in Quake3, you can create your own mesh, put it in the game, and the game will manage it exactly as all the others. Let's start with skinning!
</p>
<h3> <span class="mw-headline" id="How_does_a_skin_work.3F">How does a skin work?</span></h3>
<p>To begin, let's say that a skin is nothing more than a mesh.
This mesh is composed by weighted vertexes: each vertex is associated to a bone, and can be influenced more or less by the movement of this bone. Moving a bone, results in a movement of the associated vertexes.
</p><p>So each vertex don't have only coordinates, but also information about a bone and a weight relative to that bone.
</p><p>Usually you may want associate a single mesh to a bone system, but it's also possible to associate a mesh to each bone.
Since this is easiest, we start from this: each bone has a polygon associated with it: moving the bone results in moving the polygon.
</p><p>When we'll get more experienced, we'll try to associate a whole mesh to the bones by weighting it's vertexes.
</p>
<h4> <span class="mw-headline" id="Skinning_with_multiple_polygons">Skinning with multiple polygons</span></h4>
<p>To skin a polygon on a bone you can think that each vertex of the bone is just an offset of each vertex from the bone.
The drawing is quite simple: you know from the code above that to draw a bone(x, y, a, l) you have just to
</p>
<ol><li>translate the matrix where the bone starts
</li><li>rotate the matrix of a number of degrees
</li><li>draw the length of the bone
</li><li>translate again the matrix to the ending position
</li></ol>
<p>To draw a polygon, you should only to draw the polygon instead of the bone.
</p><p>Of course the polygon must be designed to fit on the bone when the angle value is 0: if you draw a mesh rotated of 0° on a bone of 30°, the result is wrong, and you see the mesh rotated 30° more than the bone.
</p><p>To be more clear: the bones I used above, start always in an horizontal position, since I set length to be the translation on the x axis.
So, a mesh drawn for these bones must be drawn in an horizontal position.
</p><p>I did a simple example of skinning a polygon (GL_QUAD) on a line, take a look to the code: <a href="http://content.gpwiki.org/index.php/File:Bbs_skinning.c" title="File:Bbs skinning.c">simple skinning example</a>
</p><p>Now we should apply this example to our model, keeping in mind that our system have a hierarchal structure.
First we have to find where we can save mesh info: since we attach some vertices to a bone, we can also add a vertex list in the bone, so we have just to load a mesh for each bone and then we can draw the mesh with a little modification of the draw code.
So I just defined a Vertex structure, a very simple one, and added an array of 4 elements in my Bone struct:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="co2">#define MAX_VXCOUNT				4</span>
&nbsp;
 <span class="kw4">typedef</span> <span class="kw4">struct</span>
 <span class="br0">{</span>
 	<span class="kw4">float</span> x<span class="sy0">,</span>	<span class="coMULTI">/* Coords */</span>
 		  y<span class="sy0">,</span>
 		  r<span class="sy0">,</span>	<span class="coMULTI">/* Colors or texture infos */</span>
 		  g<span class="sy0">,</span>
 		  b<span class="sy0">;</span>
 <span class="br0">}</span> Vertex<span class="sy0">;</span>
&nbsp;
 <span class="kw4">typedef</span> <span class="kw4">struct</span> _Bone
 <span class="br0">{</span>
 	...
&nbsp;
 	<span class="me1">Uint32</span> vertexCount<span class="sy0">;</span>
 	Vertex vertex<span class="br0">[</span>MAX_VXCOUNT<span class="br0">]</span><span class="sy0">;</span>
 <span class="br0">}</span> Bone<span class="sy0">;</span></pre></div></div>
<p>Then I created a simple function which create some geoms on the bones. Actually these geoms are generated by the code, but you may prefer to import them from a file.
</p><p>This function is simple: it scan the whole tree and create for each bone an horizontal mesh, with the same len of the bone, giving a random color at each vertex.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> boneGenQuads<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>root<span class="br0">)</span>
 		<span class="kw1">return</span><span class="sy0">;</span>
&nbsp;
 	root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me1">x</span> <span class="sy0">=</span> <span class="nu16">0.0</span><span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me1">y</span> <span class="sy0">=</span> <span class="nu16">5.0</span><span class="sy0">;</span>
&nbsp;
 	root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span>.<span class="me1">x</span> <span class="sy0">=</span> <span class="nu16">0.0</span><span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span>.<span class="me1">y</span> <span class="sy0">=</span> <span class="sy0">-</span><span class="nu16">5.0</span><span class="sy0">;</span>
&nbsp;
 	root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span>.<span class="me1">x</span> <span class="sy0">=</span> root<span class="sy0">-&gt;</span>l<span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span>.<span class="me1">y</span> <span class="sy0">=</span> <span class="sy0">-</span><span class="nu16">5.0</span><span class="sy0">;</span>
&nbsp;
 	root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span>.<span class="me1">x</span> <span class="sy0">=</span> root<span class="sy0">-&gt;</span>l<span class="sy0">;</span>
 	root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span>.<span class="me1">y</span> <span class="sy0">=</span> <span class="nu16">5.0</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">4</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">r</span> <span class="sy0">=</span> <span class="br0">(</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">256</span><span class="br0">)</span> <span class="sy0">/</span> <span class="nu16">256.0</span><span class="sy0">;</span>
 		root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">g</span> <span class="sy0">=</span> <span class="br0">(</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">256</span><span class="br0">)</span> <span class="sy0">/</span> <span class="nu16">256.0</span><span class="sy0">;</span>
 		root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">b</span> <span class="sy0">=</span> <span class="br0">(</span><span class="kw3">rand</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">%</span> <span class="nu0">256</span><span class="br0">)</span> <span class="sy0">/</span> <span class="nu16">256.0</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> root<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		boneGenQuads<span class="br0">(</span>root<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>And then we've to modify the boneDraw function, to draw the mesh (actually, it draws also the bones over the meshes)
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> boneDraw<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="sy0">,</span> <span class="kw4">int</span> selected<span class="br0">)</span>
 <span class="br0">{</span>
 	...
 	<span class="me1">glTranslatef</span><span class="br0">(</span>root<span class="sy0">-&gt;</span>x<span class="sy0">,</span> root<span class="sy0">-&gt;</span>y<span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
 	glRotatef<span class="br0">(</span>RAD2DEG<span class="br0">(</span>root<span class="sy0">-&gt;</span>a<span class="br0">)</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/**** This code draws the quads ****/</span>
 	glBegin<span class="br0">(</span>GL_QUADS<span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">4</span><span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		<span class="br0">{</span>
 			glColor3f<span class="br0">(</span>root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">r</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">g</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">b</span><span class="br0">)</span><span class="sy0">;</span>
 			glVertex2f<span class="br0">(</span>root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">x</span><span class="sy0">,</span> root<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">y</span><span class="br0">)</span><span class="sy0">;</span>
 		<span class="br0">}</span>
 	glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Then draw the bones normally */</span>
 	glBegin<span class="br0">(</span>GL_LINES<span class="br0">)</span><span class="sy0">;</span>
 	...
 <span class="br0">}</span></pre></div></div>
<p>Here it is&nbsp;:D
</p>
<center><a href="http://content.gpwiki.org/index.php/File:Bbs_quad_man.png" class="image" title="A humanoid skeletal structure with some quads as skin"><img alt="A humanoid skeletal structure with some quads as skin" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/Bbs_quad_man.png" width="250" height="266"></a></center>
<p>As you can see, the joints are <i>very</i> visible, as I said in the introduction. Of course, we can reduce this effect using entire meshes, that we'll see in next section.
</p><p><i>Well, since I made this tutorial just to learn how to use bone structures, and this is exactly what I need, I thin I'll not update this tutorial any more. You have to continue by yourself, learning all the 3D math and complex stuff alone.</i>
</p><p>Joking&nbsp;;) Anyway, I reached my objective, since at this point, this kind of structure is usable in simple game.
</p>
<h4> <span class="mw-headline" id="Working_on_joints">Working on joints</span></h4>
<p>As said before, having a poly for each bone is simple to implement, but actually it isn't eyecandy since joints are very visible. It would be great to have something that can hide the joints, or at least make them beauty.
</p><p>We can obtain a better result by connecting two bones like this:
</p>
<center><a href="http://content.gpwiki.org/index.php/File:Bbs_soft_joint.png" class="image" title="Soft joint between polygons"><img alt="Soft joint between polygons" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/Bbs_soft_joint.png" width="494" height="150"></a></center>
<p>To be honest, I found difficult to implement a such technique, because the bone system we are using is stored in a hierarchal way, so the transformations on the vertices are cumulative and called in a recursive way.
</p><p>At the moment, in my mind I've 3 solutions
</p>
<dl><dt>Draw the joint from the parent
</dt><dd>We take all the vertex of the joint, translate them to get their final position, and then create an algorithm that create the joint between these.
</dd><dt>Draw the joint from both bones
</dt><dd>When we draw the parent, we draw half bone toward it's child bones, then when drawing the children, we draw the other half toward the father.
</dd><dt>Draw the joint from the outside
</dt><dd>We draw all the structure without joints, but while drawing we store data about joint in a global structure. This will be used by a routine to create all the joints at once.
</dd></dl>
<p>These are the solution I found by myself, I didn't found any paper about this, so I'll write only my experience. If someone know more, please add his knowledge.
</p><p>The first method seems good to me, but this involve transformations on the vertex: if I'm the parent, with my own translation matrix, and get vertex of my child, I must remember that the vertex is relative to my child, which is relative to me. So I need to translate these vertexes to get their correct position.
</p><p>The second method is also good, because this is allow to create multiple joints without needing to translate the vertexes, but if the algorithm to create the joint is wrong, this can create inconsistencies in the final result.
</p><p>The third way don't seem too efficient to me, but this allow you to have a global view of the whole model, so this is good if you intend to perform other operations on the vertex of the model.
</p><p>Also note that I'll use rectangle as skin, and I'm assuming that the first 2 vertexes of the bone are vertex[0] and vertex[1], and the last two are vertex[vertexCount - 2] and vertex[vertexCount - 1]. These joint will be used by these algorithms, so if you want to give other shapes to the bone, keep in mind that a joint is made by these vertexes.
</p>
<h5> <span class="mw-headline" id="Parent-side_drawing">Parent-side drawing</span></h5>
<p>Drawing from the parent mean that when we draw a bone, we check if it have children. If it is the case, get the children's vertex which are involved in the joint, translate them to be relative to the parent position and finally draw the joint between the bones.
</p><p>We need to
</p>
<ol><li>Get the vertices involved
</li><li>Transform the vertices
</li><li>Draw the joint
</li></ol>
<p>As said before, I'm assuming 2 beginning and ending vertexes with fixed indexes, so first of all let's get that vertices:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">int</span> boneGetJoints<span class="br0">(</span>Bone <span class="sy0">*</span>b<span class="sy0">,</span> Vertex <span class="sy0">*</span>v<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i <span class="sy0">,</span>
 		cnt <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw4">float</span> m<span class="br0">[</span><span class="nu0">4</span> <span class="sy0">*</span> <span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span>
 		  x0<span class="sy0">,</span>
 		  y0<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>b <span class="sy0">||</span> <span class="sy0">!</span>v <span class="sy0">||</span> <span class="sy0">!</span><span class="br0">(</span>b<span class="sy0">-&gt;</span>childCount<span class="br0">)</span><span class="br0">)</span>
 		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* We are creating a joint between this bone b and its children
 	 * so get its ending vertexes
 	 */</span>
 	v<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> b<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>b<span class="sy0">-&gt;</span>vertexCount <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">]</span><span class="sy0">;</span>
 	v<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> b<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>b<span class="sy0">-&gt;</span>vertexCount <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
 	cnt <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Now get first 2 vertex for each children */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> b<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i <span class="sy0">+=</span> <span class="nu0">2</span><span class="br0">)</span>	
 	<span class="br0">{</span>
 		v<span class="br0">[</span><span class="nu0">2</span> <span class="sy0">+</span> i<span class="br0">]</span> <span class="sy0">=</span> b<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
 		v<span class="br0">[</span><span class="nu0">3</span> <span class="sy0">+</span> i<span class="br0">]</span> <span class="sy0">=</span> b<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
 		cnt <span class="sy0">+=</span> <span class="nu0">2</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="kw1">return</span> cnt<span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Now we have to translate them, so let's add translations to the vertices:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">int</span> boneGetJoints<span class="br0">(</span>Bone <span class="sy0">*</span>b<span class="sy0">,</span> Vertex <span class="sy0">*</span>v<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i <span class="sy0">,</span>
 		cnt <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw4">float</span> m<span class="br0">[</span><span class="nu0">4</span> <span class="sy0">*</span> <span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span>
 		  x0<span class="sy0">,</span>
 		  y0<span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>b <span class="sy0">||</span> <span class="sy0">!</span>v <span class="sy0">||</span> <span class="sy0">!</span><span class="br0">(</span>b<span class="sy0">-&gt;</span>childCount<span class="br0">)</span><span class="br0">)</span>
 		<span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* We are creating a joint between this bone b and its children
 	 * so get its ending vertexes
 	 */</span>
 	v<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> b<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>b<span class="sy0">-&gt;</span>vertexCount <span class="sy0">-</span> <span class="nu0">2</span><span class="br0">]</span><span class="sy0">;</span>
 	v<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> b<span class="sy0">-&gt;</span>vertex<span class="br0">[</span>b<span class="sy0">-&gt;</span>vertexCount <span class="sy0">-</span> <span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
 	cnt <span class="sy0">=</span> <span class="nu0">2</span><span class="sy0">;</span>
&nbsp;
 	glPushMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 	glLoadIdentity<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Translate the vertex for the length of the bone */</span>
 	glTranslatef<span class="br0">(</span>b<span class="sy0">-&gt;</span>l<span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Now get first 2 vertex for each children */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> b<span class="sy0">-&gt;</span>childCount<span class="sy0">;</span> i <span class="sy0">+=</span> <span class="nu0">2</span><span class="br0">)</span>	
 	<span class="br0">{</span>
 		v<span class="br0">[</span><span class="nu0">2</span> <span class="sy0">+</span> i<span class="br0">]</span> <span class="sy0">=</span> b<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">;</span>
 		v<span class="br0">[</span><span class="nu0">3</span> <span class="sy0">+</span> i<span class="br0">]</span> <span class="sy0">=</span> b<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-&gt;</span>vertex<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="sy0">;</span>
 		cnt <span class="sy0">+=</span> <span class="nu0">2</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Transform the vertices */</span>
 		glPushMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 		glRotatef<span class="br0">(</span>RAD2DEG<span class="br0">(</span>b<span class="sy0">-&gt;</span>child<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">-&gt;</span>a<span class="br0">)</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Get the current matrix */</span>
 		glGetFloatv<span class="br0">(</span>GL_MODELVIEW_MATRIX<span class="sy0">,</span> m<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Translate the vertexes multiplying the vector with the actual matrix */</span>
 		x0 <span class="sy0">=</span> v<span class="br0">[</span><span class="nu0">2</span> <span class="sy0">+</span> i<span class="br0">]</span>.<span class="me1">x</span><span class="sy0">;</span>
 		y0 <span class="sy0">=</span> v<span class="br0">[</span><span class="nu0">2</span> <span class="sy0">+</span> i<span class="br0">]</span>.<span class="me1">y</span><span class="sy0">;</span>
 		v<span class="br0">[</span><span class="nu0">2</span> <span class="sy0">+</span> i<span class="br0">]</span>.<span class="me1">x</span> <span class="sy0">=</span> x0 <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> y0 <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy0">+</span> m<span class="br0">[</span><span class="nu0">12</span><span class="br0">]</span><span class="sy0">;</span>
 		v<span class="br0">[</span><span class="nu0">2</span> <span class="sy0">+</span> i<span class="br0">]</span>.<span class="me1">y</span> <span class="sy0">=</span> x0 <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> y0 <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">+</span> m<span class="br0">[</span><span class="nu0">13</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
 		x0 <span class="sy0">=</span> v<span class="br0">[</span><span class="nu0">3</span> <span class="sy0">+</span> i<span class="br0">]</span>.<span class="me1">x</span><span class="sy0">;</span>
 		y0 <span class="sy0">=</span> v<span class="br0">[</span><span class="nu0">3</span> <span class="sy0">+</span> i<span class="br0">]</span>.<span class="me1">y</span><span class="sy0">;</span>
 		v<span class="br0">[</span><span class="nu0">3</span> <span class="sy0">+</span> i<span class="br0">]</span>.<span class="me1">x</span> <span class="sy0">=</span> x0 <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> y0 <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy0">+</span> m<span class="br0">[</span><span class="nu0">12</span><span class="br0">]</span><span class="sy0">;</span>
 		v<span class="br0">[</span><span class="nu0">3</span> <span class="sy0">+</span> i<span class="br0">]</span>.<span class="me1">y</span> <span class="sy0">=</span> x0 <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> y0 <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">+</span> m<span class="br0">[</span><span class="nu0">13</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
 		glPopMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	glPopMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">return</span> cnt<span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Now we can use these vertex in the drawing function, creating a polygon between these vertex:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> boneDraw<span class="br0">(</span>Bone <span class="sy0">*</span>root<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">float</span> <span class="sy0">*</span>col<span class="sy0">,</span>
 		  col1<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">}</span><span class="sy0">,</span>
 		  col2<span class="br0">[</span><span class="br0">]</span> <span class="sy0">=</span> <span class="br0">{</span><span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">}</span><span class="sy0">;</span>
&nbsp;
 	glPushMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Draw bones and polygons */</span>
&nbsp;
 	...
&nbsp;
 	<span class="coMULTI">/* Get joint vertexes */</span>
 	Vertex vert<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">;</span>
 	<span class="kw4">int</span> count <span class="sy0">=</span> boneGetJoints<span class="br0">(</span>root<span class="sy0">,</span> vert<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Draw the joint */</span>
 	glColor3f<span class="br0">(</span><span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
 	glBegin<span class="br0">(</span>GL_POLYGON<span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> count<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 			glVertex2f<span class="br0">(</span>vert<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">x</span><span class="sy0">,</span> vert<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">y</span><span class="br0">)</span><span class="sy0">;</span>
 	glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Translate to reach the new starting position */</span>
 	...
&nbsp;
 	<span class="coMULTI">/* Call function on my children */</span>
  	...
 	<span class="me1">glPopMatrix</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<h4> <span class="mw-headline" id="Skinning_an_entire_mesh">Skinning an entire mesh</span></h4>
<p>Now you can skin a model using a set of meshes, which can be connected to a bone. But usually this is not what you want: in fact most of the times the artists produce a single mesh and a skeletal structure for it. Then, it's the programmer that have to work on the skeleton to move the associated mesh.
In this section we try to associate a weighted set of vertex (the mesh) to a skeleton (animated).
</p><p>First, let's do an overview of the work: in this case, we have a list of vertexes and a bone structure. The difference from before is that in this case, we have an entire mesh, this means that all the vertexes are positioned relatively to the mesh. So, to get them positioned correctly, we have to compute their new position relative to the connected bones. This is done using matrix calculations.
</p><p>Let me tell you that we are going toward some complications: infact, to position each vertex, we have to calculate the absolute position for the connected bones, and then translate the vertex according to them. This is a big waste of computation, because we calculate at each refresh the position for the bones several times. To avoid this waste, programmers usually put the transformation matrix for each bone in the bone structure.
The transformation matrix is just a float[16] in the case of OpenGL. This occupies some bytes (64 bytes for each bone, if we're using 32bit floats), but this allow us to do less calculations with matrices.
</p><p>In this example I'm doing all the calculus, only for sake of this tutorial.
</p><p>Let's begin with defining the mesh: we said that the mesh is a set of vertex, and each vertex is associated to one or more bones and for each bone it have a weight.
So, we define a BoneVertex structure, which contains the data about the bones connected:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">typedef</span> <span class="kw4">struct</span>
 <span class="br0">{</span>
 	Vertex v<span class="sy0">;</span>			<span class="coMULTI">/* Info on this vertex: position color etc */</span>
 	<span class="kw4">int</span> boneCount<span class="sy0">;</span>			<span class="coMULTI">/* Number of bones this vertex is connected to*/</span>
 	<span class="kw4">float</span> weight<span class="br0">[</span>MAX_BONECOUNT<span class="br0">]</span><span class="sy0">;</span>	<span class="coMULTI">/* Weight for each bone connected */</span>
 	Bone <span class="sy0">*</span>bone<span class="br0">[</span>MAX_BONECOUNT<span class="br0">]</span><span class="sy0">;</span>	<span class="coMULTI">/* Pointer to connected bones */</span>
 <span class="br0">}</span> BoneVertex<span class="sy0">;</span></pre></div></div>
<p>And then define a Mesh structure, which contains all the vertexes:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">typedef</span> <span class="kw4">struct</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> vertexCount<span class="sy0">;</span>		<span class="coMULTI">/* Number of vertexes in this mesh */</span>
 	BoneVertex v<span class="br0">[</span>MAX_MESHVXCOUNT<span class="br0">]</span><span class="sy0">;</span>	<span class="coMULTI">/* Vertices of the mesh */</span>
 <span class="br0">}</span> Mesh<span class="sy0">;</span></pre></div></div>
<p>Now, we want acquire some data (loading the mesh file). So, let's create a function that read - again - a custom-created file format, in ASCII text (easy to handle and write). The file must contain:
</p>
<ul><li>The number of the vertexes of the mesh
</li><li>For each vertex
<ul><li>It's coordinates and info (i.e. color)
</li><li>Bones connected
</li><li>Weight for bones
</li></ul>
</li></ul>
<p>An example for this format is this:
</p>
<pre>2
11.0 22.0 Root 1.0 Head 0.0 Back 0.5
44.0 55.0 Root 1.0 Head 0.5 Back 1.0 
</pre>
<p>2 is the number of vertexes in the mesh
Then there are 2 rows, one for each vertex: the first and second floats are the position of the vertex, then follow a list of BoneName-Weight values.
</p><p>So, this is the function used for the mesh loading:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> meshLoadData<span class="br0">(</span><span class="kw4">char</span> <span class="sy0">*</span>file<span class="sy0">,</span> Mesh <span class="sy0">*</span>mesh<span class="sy0">,</span> Bone <span class="sy0">*</span>root<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">,</span> j<span class="sy0">;</span>
 	<span class="kw4">char</span> buffer<span class="br0">[</span><span class="nu0">256</span><span class="br0">]</span><span class="sy0">,</span> blist<span class="br0">[</span><span class="nu0">256</span><span class="br0">]</span><span class="sy0">,</span> <span class="sy0">*</span>tok<span class="sy0">,</span> <span class="sy0">*</span>str<span class="sy0">;</span>
 	FILE <span class="sy0">*</span>fd <span class="sy0">=</span> <span class="kw3">fopen</span><span class="br0">(</span>file<span class="sy0">,</span> <span class="st0">"r"</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw4">int</span> id<span class="sy0">;</span>
 	<span class="kw4">float</span> x<span class="sy0">,</span> y<span class="sy0">,</span> w<span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Get the number of vertexes in this mesh */</span>
 	<span class="kw3">fgets</span><span class="br0">(</span>buffer<span class="sy0">,</span> <span class="nu0">256</span><span class="sy0">,</span> fd<span class="br0">)</span><span class="sy0">;</span>
 	mesh<span class="sy0">-&gt;</span>vertexCount <span class="sy0">=</span> <span class="kw3">atoi</span><span class="br0">(</span>buffer<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="coMULTI">/* Now read the vertex data */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> mesh<span class="sy0">-&gt;</span>vertexCount<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		<span class="kw3">fgets</span><span class="br0">(</span>buffer<span class="sy0">,</span> <span class="nu0">256</span><span class="sy0">,</span> fd<span class="br0">)</span><span class="sy0">;</span>
 		<span class="kw3">sscanf</span><span class="br0">(</span>buffer<span class="sy0">,</span> <span class="st0">"%f&nbsp;%f&nbsp;%[^<span class="es1">\n</span>]<span class="es1">\n</span>"</span><span class="sy0">,</span> <span class="sy0">&amp;</span>x<span class="sy0">,</span> <span class="sy0">&amp;</span>y<span class="sy0">,</span> blist<span class="br0">)</span><span class="sy0">;</span>
 		mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">v</span>.<span class="me1">x</span> <span class="sy0">=</span> x<span class="sy0">;</span>
 		mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">v</span>.<span class="me1">y</span> <span class="sy0">=</span> y<span class="sy0">;</span>
&nbsp;
 		str <span class="sy0">=</span> blist<span class="sy0">;</span>
 		j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 		<span class="kw1">while</span> <span class="br0">(</span><span class="br0">(</span>tok <span class="sy0">=</span> <span class="kw3">strtok</span><span class="br0">(</span>str<span class="sy0">,</span> <span class="st0">" "</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 		<span class="br0">{</span>
 			str <span class="sy0">=</span> NULL<span class="sy0">;</span>
 			mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">bone</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> boneFindByName<span class="br0">(</span>root<span class="sy0">,</span> tok<span class="br0">)</span><span class="sy0">;</span>
 			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"Vertex&nbsp;%d bone&nbsp;%s"</span><span class="sy0">,</span> j<span class="sy0">,</span> tok<span class="br0">)</span><span class="sy0">;</span>
 			tok <span class="sy0">=</span> <span class="kw3">strtok</span><span class="br0">(</span>NULL<span class="sy0">,</span> <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
 			mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">weight</span><span class="br0">[</span>j<span class="br0">]</span> <span class="sy0">=</span> <span class="kw3">atof</span><span class="br0">(</span>tok<span class="br0">)</span><span class="sy0">;</span>
 			<span class="kw3">printf</span><span class="br0">(</span><span class="st0">" is weighted&nbsp;%f<span class="es1">\n</span>"</span><span class="sy0">,</span> mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">weight</span><span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 			j<span class="sy0">++;</span>
 		<span class="br0">}</span>
 		<span class="coMULTI">/* Count of relations */</span>
 		mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">boneCount</span> <span class="sy0">=</span> j<span class="sy0">;</span>
 		<span class="kw3">printf</span><span class="br0">(</span><span class="st0">"This vertex has&nbsp;%d relations<span class="es1">\n</span>"</span><span class="sy0">,</span> j<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="br0">}</span>
&nbsp;
 	<span class="kw3">fclose</span><span class="br0">(</span>fd<span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Now we have a mesh loaded, this is related to some bones, and we need that vertices moves with their bones. So, we want to define a function that, given the mesh, draw its vertices relatively the connected bones.
To start, we assume a single bone with weight 1.0.
</p>
<ul><li>Get the current rotation center for the vertex
</li><li>Rotate the vertex around the center
</li></ul>
<p>The center is actually where the bone is (the absolute coords of the bone). Since actually i didn't store the absolute coords into the bone structure, i've to calculate it with matrix transformations. Of course, it's better to put relative and absolute positions in the bone struct to avoid multiple calculation of the same data.
</p><p>To get the position of the bone i use OpenGL and some matrix math:
</p>
<ol><li>We start from a leave in the tree
</li><li>Calculate it's parent position recursively
</li><li>Translate the bone to it's relative position to the parent
</li><li>Rotate the bone of it's angle
</li><li>Get the current matrix
</li><li>Get the bone position
</li></ol>
<p>To get the matrix there are these functions
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> getBoneParentMatrix<span class="br0">(</span>Bone <span class="sy0">*</span>b<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>b<span class="br0">)</span>
 		<span class="kw1">return</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span>b<span class="sy0">-&gt;</span>prev<span class="br0">)</span>
 	<span class="br0">{</span>
 		getBoneParentMatrix<span class="br0">(</span>b<span class="sy0">-&gt;</span>prev<span class="br0">)</span><span class="sy0">;</span>
 		glTranslatef<span class="br0">(</span>b<span class="sy0">-&gt;</span>prev<span class="sy0">-&gt;</span>l<span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	glTranslatef<span class="br0">(</span>b<span class="sy0">-&gt;</span>x<span class="sy0">,</span> b<span class="sy0">-&gt;</span>y<span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span> <span class="coMULTI">/* For a connected stucture, this is usually 0, 0, 0 */</span>
 	glRotatef<span class="br0">(</span>RAD2DEG<span class="br0">(</span>b<span class="sy0">-&gt;</span>a<span class="br0">)</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span>
&nbsp;
 <span class="kw4">void</span> getBoneMatrix<span class="br0">(</span>Bone <span class="sy0">*</span>b<span class="sy0">,</span> <span class="kw4">float</span> m<span class="br0">[</span><span class="nu0">16</span><span class="br0">]</span><span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">float</span> pm<span class="br0">[</span><span class="nu0">16</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span><span class="sy0">!</span>b<span class="br0">)</span>
 		<span class="kw1">return</span><span class="sy0">;</span>
&nbsp;
 	glPushMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 	glLoadIdentity<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	<span class="kw1">if</span> <span class="br0">(</span>b<span class="sy0">-&gt;</span>prev<span class="br0">)</span>
 	<span class="br0">{</span>
 		getBoneParentMatrix<span class="br0">(</span>b<span class="sy0">-&gt;</span>prev<span class="br0">)</span><span class="sy0">;</span>
 		glTranslatef<span class="br0">(</span>b<span class="sy0">-&gt;</span>prev<span class="sy0">-&gt;</span>l<span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* Now we are at the end of parent's bone
 	 * rotate for this bone and
 	 * get the matrix and
 	 * return
 	 */</span>
 	glRotatef<span class="br0">(</span>RAD2DEG<span class="br0">(</span>b<span class="sy0">-&gt;</span>a<span class="br0">)</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
 	glGetFloatv<span class="br0">(</span>GL_MODELVIEW_MATRIX<span class="sy0">,</span> m<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glPopMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>The bone positions (x, y, z) are the 12, 13 and 14th elements of the matrix. We can get them to get the current bone position.
Next step is to define our function, which draws the bones.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> meshDraw<span class="br0">(</span>Mesh <span class="sy0">*</span>mesh<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">,</span>
 		n<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">float</span> v<span class="br0">[</span>MAX_VXCOUNT <span class="sy0">*</span> MAX_BONECOUNT<span class="br0">]</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="sy0">,</span> <span class="coMULTI">/* End vertexes */</span>
 		  m<span class="br0">[</span><span class="nu0">16</span><span class="br0">]</span><span class="sy0">,</span>
 		  tmp<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">,</span>
 		  x<span class="sy0">,</span> y<span class="sy0">;</span>
&nbsp;
 	n <span class="sy0">=</span> mesh<span class="sy0">-&gt;</span>vertexCount<span class="sy0">;</span>
&nbsp;
 	glPointSize<span class="br0">(</span><span class="nu16">3.0</span><span class="br0">)</span><span class="sy0">;</span>
 	<span class="coMULTI">/* Processing loop */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		glPushMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 		glLoadIdentity<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 		<span class="coMULTI">/* Get the bone position */</span>
 		getBoneMatrix<span class="br0">(</span>mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">bone</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> m<span class="br0">)</span><span class="sy0">;</span>
 		x <span class="sy0">=</span> m<span class="br0">[</span><span class="nu0">12</span><span class="br0">]</span><span class="sy0">;</span>
 		y <span class="sy0">=</span> m<span class="br0">[</span><span class="nu0">13</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Go to the bone position */</span>
 		glTranslatef<span class="br0">(</span>x<span class="sy0">,</span> y<span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Rotate the vertex relatively the bone position */</span>
 		glRotatef<span class="br0">(</span>RAD2DEG<span class="br0">(</span>getBoneAngle<span class="br0">(</span>mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">bone</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Get the matrix */</span>
 		glGetFloatv<span class="br0">(</span>GL_MODELVIEW_MATRIX<span class="sy0">,</span> m<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		glPopMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Save the temporary point */</span>
 		tmp<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 		tmp<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">v</span>.<span class="me1">y</span><span class="sy0">;</span>
 		tmp<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
 		tmp<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Multiply the matrix for the point and save the vertex */</span>
 		v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> tmp<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> tmp<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy0">+</span> m<span class="br0">[</span><span class="nu0">12</span><span class="br0">]</span><span class="sy0">;</span>
 		v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> tmp<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> tmp<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">+</span> m<span class="br0">[</span><span class="nu0">13</span><span class="br0">]</span><span class="sy0">;</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* Draw loop */</span>
 	glPushAttrib<span class="br0">(</span>GL_ALL_ATTRIB_BITS<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glBegin<span class="br0">(</span>GL_POINTS<span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		glVertex2f<span class="br0">(</span>v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
 	glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glPopAttrib<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Here a two-pass drawing is done since you may prefer to handle vertex to build quads, triangles or lines. To do a single-pass drawing, you should remove not-allowed GL functions and use only external functions to do matrix operations (since these aren't allowed between glBegin and glEnd).
</p><p>Very good, now it's time to weight out vertexes on multiple bones.
As we said, a weighted vertex is influenced by one or more bones, and for each bone the movement can be proportional to a constant: the weight. Usually this constant is a real between 0 and 1, and the sum for all the weights is 1.
</p><p>When we draw a weighted vertex, we have to apply the linear interpolation. The calculus is done with:
</p><p><img class="tex" alt="v&#39; = \sum_{i=0}^n w_i M_i v" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/67e4bf3d8396b4fe2c7b699e923b3d9d.png">
</p><p>with
</p>
<ul><li><span class="texhtml"><i>v</i>'</span> is the resulting vector
</li><li><span class="texhtml"><i>v</i></span> is the non-transformed vector
</li><li><span class="texhtml"><i>n</i></span> is the number of associated bone
</li><li><span class="texhtml"><i>w</i><sub><i>i</i></sub></span> is weight associated with the bone
</li><li><img class="tex" alt="1 = \sum_{i=0}^n w_i" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/d921e03303097782d2775421de885cec.png">
</li><li><span class="texhtml"><i>M</i><sub><i>i</i></sub></span> is the transformation matrix for the bone
</li></ul>
<p>Now we have <b>only</b> to modify a little our function. In the previous definition, we assumed that only the first relation was valid. Now we know how to handle multiple bones, so we just have to create a loop that solve that formula.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> meshDraw<span class="br0">(</span>Mesh <span class="sy0">*</span>mesh<span class="br0">)</span>
 <span class="br0">{</span>
 	<span class="kw4">int</span> i<span class="sy0">,</span>
 		j<span class="sy0">,</span>
 		n<span class="sy0">;</span>
&nbsp;
 	<span class="kw4">float</span> v<span class="br0">[</span>MAX_VXCOUNT <span class="sy0">*</span> MAX_BONECOUNT<span class="br0">]</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="sy0">,</span> <span class="coMULTI">/* End vertexes */</span>
 		  m<span class="br0">[</span><span class="nu0">16</span><span class="br0">]</span><span class="sy0">,</span>
 		  tmp<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">;</span>
&nbsp;
 	n <span class="sy0">=</span> mesh<span class="sy0">-&gt;</span>vertexCount<span class="sy0">;</span>
&nbsp;
 	glPointSize<span class="br0">(</span><span class="nu16">3.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	tmp<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> tmp<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu16">0.0</span><span class="sy0">;</span>
 	tmp<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu16">1.0</span><span class="sy0">;</span>
 	tmp<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu16">1.0</span><span class="sy0">;</span> <span class="coMULTI">/* w is always 1.0 */</span>
&nbsp;
 	<span class="coMULTI">/* Processing loop */</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 	<span class="br0">{</span>
 		v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> <span class="nu16">0.0</span><span class="sy0">;</span>
 		tmp<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">=</span> mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">v</span>.<span class="me1">x</span><span class="sy0">;</span>
 		tmp<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">=</span> mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">v</span>.<span class="me1">y</span><span class="sy0">;</span>
&nbsp;
 		<span class="coMULTI">/* Loop thru the relations with each bone */</span>
 		<span class="kw1">for</span> <span class="br0">(</span>j <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">boneCount</span><span class="sy0">;</span> j<span class="sy0">++</span><span class="br0">)</span>
 		<span class="br0">{</span>
 			glPushMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 			glLoadIdentity<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 			<span class="coMULTI">/* Get the jth bone position */</span>
 			getBoneMatrix<span class="br0">(</span>mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">bone</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">,</span> m<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 			glTranslatef<span class="br0">(</span>m<span class="br0">[</span><span class="nu0">12</span><span class="br0">]</span><span class="sy0">,</span> m<span class="br0">[</span><span class="nu0">13</span><span class="br0">]</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="br0">)</span><span class="sy0">;</span>
 			glRotatef<span class="br0">(</span>RAD2DEG<span class="br0">(</span>getBoneAngle<span class="br0">(</span>mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">bone</span><span class="br0">[</span>j<span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">0.0</span><span class="sy0">,</span> <span class="nu16">1.0</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 			glGetFloatv<span class="br0">(</span>GL_MODELVIEW_MATRIX<span class="sy0">,</span> m<span class="br0">)</span><span class="sy0">;</span>
 			glPopMatrix<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 			v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+=</span> <span class="br0">(</span>tmp<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">+</span> tmp<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy0">+</span> m<span class="br0">[</span><span class="nu0">12</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">*</span> mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">weight</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>
 			v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+=</span> <span class="br0">(</span>tmp<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">+</span> tmp<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy0">*</span> m<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span> <span class="sy0">+</span> m<span class="br0">[</span><span class="nu0">13</span><span class="br0">]</span><span class="br0">)</span> <span class="sy0">*</span> mesh<span class="sy0">-&gt;</span>v<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">weight</span><span class="br0">[</span>j<span class="br0">]</span><span class="sy0">;</span>	
 		<span class="br0">}</span>
 	<span class="br0">}</span>
&nbsp;
 	<span class="coMULTI">/* Draw loop */</span>
 	glPushAttrib<span class="br0">(</span>GL_ALL_ATTRIB_BITS<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glBegin<span class="br0">(</span>GL_POINTS<span class="br0">)</span><span class="sy0">;</span>
 	<span class="kw1">for</span> <span class="br0">(</span>i <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i<span class="sy0">++</span><span class="br0">)</span>
 		glVertex2f<span class="br0">(</span>v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="sy0">,</span> v<span class="br0">[</span>i<span class="br0">]</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
 	glEnd<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
 	glPopAttrib<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>I created a mesh file, with some weighted vertexes, to apply to the animated humanoid of the previous section, and this works. You can find the finished and cleaned code in the bottom of the page.
</p><p>Very good, the first coding part is finished! This has been <b>very</b> useful to me - and hope to you - to understand how bones works.
Of course, there are plenty of things that must be fixed in the code - if you intend to use it in a production game. In the next section we'll talk about it.
</p>
<h1> <span class="mw-headline" id="A_3D_application_using_bones">A 3D application using bones</span></h1>
<p>We are finally here: we learned something about bones with the previous section, but now we should optimize it and prepare it for the third dimension. As I said, the above code is full of nasty things. In this section we try to get them better, to gain performances and precision with calculus.
</p>
<h2> <span class="mw-headline" id="A_check_before_starting">A check before starting</span></h2>
<p>To begin, I start saying that it would be a <i>great</i> idea to keep a relative and absolute transformation matrices in the bone. This helps a lot, because when we want to refer to a bone's space coordinate, we have just to use the bone relative matrix, and when we want to position the bone in the space, there is the absolute matrix.
</p><p>We can remove some code - gaining speed, and as you probably noticed, this kind of work requires handling of matrices, so it's better if we can use the OpenGL code to handle them (we assume that OpenGL can do faster matrix operations that our simple functions). If you want to use an external fast math library, do it now.
</p><p>Also I think it's a good idea to decide now the measure of angles: since OpenGL uses degrees for angles, I suggest to use degrees everywhere, and defining two macros for funcions like sin and cos for using degrees.
</p>
<h2> <span class="mw-headline" id="Data_structures">Data structures</span></h2>
<p>In the 2D section, I created a very simple and intuitive data structure for the bones and for the vertexes, because <i>there</i> it was important to understand how bones works. <i>Here</i> we want to gain performances, so a different structure is used. As said before, i'll use two matrices to store transformation of the bone in relative and absolute space.
</p><p>A matrix, in the OpenGL context, is a 16 element array of float or double. I'll use float since it gives a good quality in the calculations and a good speed. If you need more precision in calculations, doubles are for you. Using a matrix we can determine where the bone is located, and which is its rotation angle, but we have to keep it's length as a separate float.
</p><p>And of course we want to keep the hierarchal structure, but in the previous example I used arrays to keep information about children, now we use a different tree
</p>
<center><a href="http://content.gpwiki.org/index.php/File:Sib_tree.png" class="image" title="S-Tree"><img alt="S-Tree" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/Sib_tree.png" width="230" height="226"></a></center>
<p>This tree (that I call s-tree, but i'm quite sure it have a different name&nbsp;:P) allow us to keep an unlimited number of level and children and, in our case, performances are good since in our algorithms we don't need a direct access to the child.
</p><p>In addition, it's a good idea to avoid strings to refer to bones&nbsp;;) If you want to use a string for giving a name to a bone, you can do that, but it's faster to give a numerical ID to each bone.
</p><p>So a structure for these bones can look like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">typedef</span> <span class="kw4">struct</span> _Bone
 <span class="br0">{</span>
 <span class="kw4">int</span> id<span class="sy0">;</span>
 <span class="kw4">float</span> absMatrix<span class="br0">[</span><span class="nu0">16</span><span class="br0">]</span><span class="sy0">,</span> relMatrix<span class="br0">[</span><span class="nu0">16</span><span class="br0">]</span><span class="sy0">;</span>
 <span class="kw4">float</span> length<span class="sy0">;</span>
 <span class="kw4">struct</span> _Bone <span class="sy0">*</span>parent<span class="sy0">,</span> <span class="sy0">*</span>child<span class="sy0">,</span> <span class="sy0">*</span>brother<span class="sy0">;</span>
 <span class="br0">}</span> Bone<span class="sy0">;</span></pre></div></div>
<h1> <span class="mw-headline" id="Source_codes">Source codes</span></h1>
<ul><li><a href="http://content.gpwiki.org/index.php/File:Bones2d.c" title="File:Bones2d.c">Test source for 2D bones</a> - This is a very basic implementation of this tutorial. Improvements will come later...
</li><li><a href="http://content.gpwiki.org/index.php/File:Bbs_skinning.c" title="File:Bbs skinning.c">File:Bbs skinning.c</a> 
</li><li><a href="http://content.gpwiki.org/index.php/File:Bbs_snakeSkel.txt" title="File:Bbs snakeSkel.txt">File:Bbs snakeSkel.txt</a> 
</li><li><a href="http://content.gpwiki.org/index.php/File:Bbs_snakeMesh.txt" title="File:Bbs snakeMesh.txt">File:Bbs snakeMesh.txt</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 608/1000000
Post-expand include size: 175/2097152 bytes
Template argument size: 28/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key gpw_mw_db-mw_:pcache:idhash:3077-0!1!0!!en-gb!2!edit=0 and timestamp 20130331205418 -->
<div class="printfooter">
Retrieved from "<a href="./OpenGL Tutorials Basic Bones System - GPWiki_files/OpenGL Tutorials Basic Bones System - GPWiki.html">http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System</a>"</div>
				<!-- /bodytext -->
								<!-- catlinks -->
				<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks"><a href="http://content.gpwiki.org/index.php/Special:Categories" title="Special:Categories">Categories</a>: <span dir="ltr"><a href="http://content.gpwiki.org/index.php/Category:C_and_OpenGL" title="Category:C and OpenGL">C and OpenGL</a></span> | <span dir="ltr"><a href="http://content.gpwiki.org/index.php/Category:All_C_articles" title="Category:All C articles">All C articles</a></span> | <span dir="ltr"><a href="http://content.gpwiki.org/index.php/Category:All_OpenGL_articles" title="Category:All OpenGL articles">All OpenGL articles</a></span></div></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
					<li id="pt-login"><a href="http://content.gpwiki.org/index.php?title=Special:UserLogin&returnto=OpenGL:Tutorials:Basic_Bones_System" title="You are encouraged to log in; however, it is not mandatory [ctrl-option-o]" accesskey="o">Log in</a></li>
			</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li id="ca-nstab-main" class="selected"><span><a href="./OpenGL Tutorials Basic Bones System - GPWiki_files/OpenGL Tutorials Basic Bones System - GPWiki.html" title="View the content page [ctrl-option-c]" accesskey="c">Page</a></span></li>
					<li id="ca-talk"><span><a href="http://content.gpwiki.org/index.php/Talk:OpenGL:Tutorials:Basic_Bones_System" title="Discussion about the content page [ctrl-option-t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="./OpenGL Tutorials Basic Bones System - GPWiki_files/OpenGL Tutorials Basic Bones System - GPWiki.html">Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://content.gpwiki.org/index.php?title=OpenGL:Tutorials:Basic_Bones_System&action=edit" title="This page is protected.
You can view its source [ctrl-option-e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible "><span><a href="http://content.gpwiki.org/index.php?title=OpenGL:Tutorials:Basic_Bones_System&action=history" title="Past revisions of this page [ctrl-option-h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="http://content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
<form action="http://www.google.com/cse" id="cse-search-box" target="_blank">
  <div>
    <input type="hidden" name="cx" value="partner-pub-8199339419526862:1119135372">
    <input type="hidden" name="ie" value="UTF-8">
    <input type="text" name="q" size="20" style="background-image: url(http://www.google.com/cse/intl/en/images/google_custom_search_watermark.gif); background-color: rgb(255, 255, 255); background-position: 0% 50%; background-repeat: no-repeat no-repeat;">
    <input type="submit" name="sa" value="Search">
  </div>
<input name="siteurl" type="hidden" value="content.gpwiki.org/index.php/OpenGL:Tutorials:Basic_Bones_System"><input name="ref" type="hidden" value="www.opengl.org/wiki/Skeletal_Animation"><input name="ss" type="hidden" value=""></form>

<script type="text/javascript" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/brand"></script>

</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(/images/gpwikilogo.png);" href="http://content.gpwiki.org/index.php/Main_Page" title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id="p-navigation">
	<h5>Navigation</h5>
	<div class="body">
				<ul>
					<li id="n-Site-Homepage"><a href="http://www.gpwiki.org/">Site Homepage</a></li>
					<li id="n-Wiki-Main-Page"><a href="http://content.gpwiki.org/">Wiki Main Page</a></li>
					<li id="n-Message-Board"><a href="http://forum.gpwiki.org/">Message Board</a></li>
					<li id="n-Featured-Image"><a href="http://www.gpwiki.org/iotd">Featured Image</a></li>
					<li id="n-currentevents"><a href="http://content.gpwiki.org/index.php/GPWiki:Current_events" title="Find background information on current events">Current events</a></li>
					<li id="n-recentchanges"><a href="http://content.gpwiki.org/index.php/Special:RecentChanges" title="The list of recent changes in the wiki [ctrl-option-r]" accesskey="r">Recent changes</a></li>
					<li id="n-randompage"><a href="http://content.gpwiki.org/index.php/Special:Random" title="Load a random page [ctrl-option-x]" accesskey="x">Random page</a></li>
					<li id="n-help"><a href="http://content.gpwiki.org/index.php/Help:Contents" title="The place to find out">Help</a></li>
				</ul>
			</div>
</div>

<!-- /navigation -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id="p-tb">
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
					<li id="t-whatlinkshere"><a href="http://content.gpwiki.org/index.php/Special:WhatLinksHere/OpenGL:Tutorials:Basic_Bones_System" title="List of all wiki pages that link here [ctrl-option-j]" accesskey="j">What links here</a></li>
						<li id="t-recentchangeslinked"><a href="http://content.gpwiki.org/index.php/Special:RecentChangesLinked/OpenGL:Tutorials:Basic_Bones_System" title="Recent changes in pages linked from this page [ctrl-option-k]" accesskey="k">Related changes</a></li>
																																										<li id="t-specialpages"><a href="http://content.gpwiki.org/index.php/Special:SpecialPages" title="List of all special pages [ctrl-option-q]" accesskey="q">Special pages</a></li>
									<li id="t-print"><a href="http://content.gpwiki.org/index.php?title=OpenGL:Tutorials:Basic_Bones_System&printable=yes" rel="alternate" title="Printable version of this page [ctrl-option-p]" accesskey="p">Printable version</a></li>
						<li id="t-permalink"><a href="http://content.gpwiki.org/index.php?title=OpenGL:Tutorials:Basic_Bones_System&oldid=31020" title="Permanent link to this revision of the page">Permanent link</a></li>
						</ul>
	</div>

 <center>
 &nbsp;<br>
  <script type="text/javascript"><!--
  google_ad_client = "ca-pub-8199339419526862";
  /* GPWiki Menu Sidebar */
  google_ad_slot = "4458594054";
  google_ad_width = 120;
  google_ad_height = 600;
  //-->
  </script>
  <script type="text/javascript" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/show_ads.js">
  </script>
</center>


</div>


<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
											<ul id="footer-info">
																	<li id="footer-info-lastmod"> This page was last modified on 2 November 2011, at 11:36.</li>
																							<li id="footer-info-viewcount">This page has been accessed 72,975 times.</li>
																							<li id="footer-info-copyright">Content is available under <a href="http://www.gnu.org/licenses/old-licenses/fdl-1.2.txt" class="external ">GNU Free Documentation License 1.2</a>.</li>
															</ul>
															<ul id="footer-places">
																	<li id="footer-places-privacy"><a href="http://content.gpwiki.org/index.php/GPWiki:Privacy_policy" title="GPWiki:Privacy policy">Privacy policy</a></li>
																							<li id="footer-places-about"><a href="http://content.gpwiki.org/index.php/GPWiki:About" title="GPWiki:About">About GPWiki</a></li>
																							<li id="footer-places-disclaimer"><a href="http://content.gpwiki.org/index.php/GPWiki:General_disclaimer" title="GPWiki:General disclaimer">Disclaimers</a></li>
															</ul>
											<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://www.gnu.org/licenses/old-licenses/fdl-1.2.txt"><img src="./OpenGL Tutorials Basic Bones System - GPWiki_files/gnu-fdl.png" alt="GNU Free Documentation License 1.2" width="88" height="31"></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="./OpenGL Tutorials Basic Bones System - GPWiki_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		
<script src="./OpenGL Tutorials Basic Bones System - GPWiki_files/load.php"></script><script src="./OpenGL Tutorials Basic Bones System - GPWiki_files/load(1).php"></script>
<script>if ( window.mediaWiki ) {
	mediaWiki.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "OpenGL:Tutorials:Basic_Bones_System", "wgTitle": "OpenGL:Tutorials:Basic Bones System", "wgAction": "view", "wgArticleId": 3077, "wgIsArticle": true, "wgUserName": null, "wgUserGroups": ["*"], "wgCurRevisionId": 31020, "wgCategories": ["C and OpenGL", "All C articles", "All OpenGL articles"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script>
<script>if ( window.mediaWiki ) {
	mediaWiki.loader.load(["mediawiki.util", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
	mediaWiki.loader.go();
}
</script><script type="text/javascript" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/load(2).php"></script>

<script>if ( window.mediaWiki ) {
	mediaWiki.user.options.set({"ccmeonemails":0,"cols":80,"contextchars":50,"contextlines":5,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
	"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en-gb","language":"en-gb","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs510":false,"searchNs511":false});;mediaWiki.loader.state({"user.options":"ready"});
}
</script>		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<!-- Served in 0.259 secs. -->			

<div style="display: block; visibility: hidden; position: absolute; width: 314px; left: -10000px; top: -10000px; height: 68px; z-index: 2000000000;"><table cellpadding="0" cellspacing="0" dir="ltr" style="width: 314px; height: 68px;" frame="void" rules="none" class="gc-bubbleDefault pls-container"><tbody><tr class="gc-reset"><td class="pls-topLeft gc-reset"><img class="gc-reset" width="1" height="1" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/border_3.gif"></td><td class="pls-topTail gc-reset"><img class="pls-tailbottom gc-reset" width="15" height="9" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif" style="display: inline; left: 9px; top: 0px;"><img class="pls-spacerbottom gc-reset" width="1" height="1" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif" style="display: none;"></td><td class="pls-topRight gc-reset"><img class="gc-reset" width="1" height="1" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/border_3.gif"></td></tr><tr class="gc-reset"><td class="pls-vertShimLeft gc-reset"><img class="gc-reset" width="1" height="4" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif"></td><td class="pls-vertShim gc-reset"><img class="gc-reset" width="1" height="4" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif"></td><td class="pls-vertShimRight gc-reset"><img class="pls-dropTR gc-reset" width="5" height="4" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif"></td></tr><tr class="gc-reset"><td class="pls-contentLeft gc-reset"><img class="pls-tailright gc-reset" width="9" height="15" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif" style="display: none;"><img class="pls-spacerright gc-reset" width="1" height="1" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif" style="display: block;"></td><td class="pls-contentWrap gc-reset"><img class="pls-spinner " width="16" height="16" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spinner-1.gif" style="visibility: hidden;"><div class="goog-bubble-content gc-reset" style="width: 308px; height: 50px;"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="margin: 0px; position: absolute; z-index: 1; border-style: none; outline: none; width: 308px; height: 50px;" tabindex="0" vspace="0" width="100%" id="I2_1364763842582" name="I2_1364763842582" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/hover.html"></iframe></div></td><td class="pls-dropRight gc-reset"><img class="pls-tailleft gc-reset" width="12" height="19" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif" style="display: none;"><img class="pls-spacerleft gc-reset" width="1" height="1" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif" style="display: block;"></td></tr><tr class="gc-reset"><td class="pls-bottomLeft gc-reset"><img class="gc-reset" width="1" height="1" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/border_3.gif"></td><td class="gc-reset"><table cellpadding="0" cellspacing="0" style="width:100%" class="gc-reset"><tbody><tr class="gc-reset"><td class="pls-vert gc-reset"><img class="pls-dropBL gc-reset" width="4" height="5" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif"></td><td class="pls-dropBottom gc-reset"><img class="pls-tailtop gc-reset" width="19" height="13" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif" style="display: none;"><img class="pls-spacertop gc-reset" width="1" height="1" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif" style="display: block;"></td></tr></tbody></table></td><td class="pls-vert gc-reset"><img class="pls-dropBR gc-reset" width="5" height="5" src="./OpenGL Tutorials Basic Bones System - GPWiki_files/spacer.gif"></td></tr></tbody></table></div><ins style="position: absolute; background-color: transparent; left: 627px; top: 100px; width: 32px; height: 20px; z-index: -10000; background-position: initial initial; background-repeat: initial initial;"></ins></body></html>