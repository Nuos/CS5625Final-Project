/**
 * material_lambertian.vp
 * 
 * Vertex shader shader which writes material information needed for Lambertian shading to
 * the gbuffer.
 * 
 * Written for Cornell CS 5625 (Interactive Computer Graphics).
 * Copyright (c) 2012, Computer Science Department, Cornell University.
 * 
 * @author Asher Dunn (ad488)
 * @date 2012-03-27
 */

/* Pass eyespace position and normal, and texcoord, to the fragment shader. */
varying vec3 EyespacePosition;
varying vec3 EyespaceNormal;
varying vec2 TexCoord;

/* Textures and flags for whether they exist. */
uniform float SamplerWidth;
uniform float SamplerHeight;
uniform sampler2DRect SandDuneHeightMap;
uniform bool HasSandDuneHeightMap;

const float sampleRadius = 4.0;

void main()
{
	TexCoord = vec2(gl_MultiTexCoord0);
	TexCoord.x *= SamplerWidth;
	TexCoord.y *= SamplerHeight;
	vec4 newVertexPos = gl_Vertex;
	vec3 bump = gl_Normal;
	
	float h = 0.1;
	if (HasSandDuneHeightMap){
		vec4 dv = vec4(0.0);
		for(float i = -sampleRadius ; i <= sampleRadius; i += 1.0 ){
			for(float j = -sampleRadius ; j <= sampleRadius; j += 1.0 ){
				dv += texture2DRect(SandDuneHeightMap,vec2(TexCoord.x + i, TexCoord.y + j));
			}
		}
		dv /= (sampleRadius+1.0) * (sampleRadius+1.0);
		newVertexPos = vec4(0.0, h * (dv.x) - 0.5 * h , 0.0, 0.0) + gl_Vertex;
		
 //   	float h01 = texture2DRect(SandDuneHeightMap, TexCoord + vec2(-1,0) ).x;
  //  	float h21 = texture2DRect(SandDuneHeightMap, TexCoord + vec2(1,0) ).x;
 //   	float h10 = texture2DRect(SandDuneHeightMap, TexCoord + vec2(0,-1) ).x;
 //   	float h12 = texture2DRect(SandDuneHeightMap, TexCoord + vec2(0,1) ).x;
 //   	vec3 va = normalize(vec3(2.0,h21-h01,0.0));
 //   	vec3 vb = normalize(vec3(0.0,h12-h10,-2.0));
 //   	bump = cross(va,vb);
	}
	
	

	gl_Position = gl_ModelViewProjectionMatrix * newVertexPos;
	EyespacePosition = vec3(gl_ModelViewMatrix * newVertexPos);
	EyespaceNormal = normalize(gl_NormalMatrix * bump);	
}
